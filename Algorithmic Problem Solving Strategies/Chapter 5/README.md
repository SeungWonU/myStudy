# 05 알고리즘의 정당성 증명
## 5-1 도입
* ### 알고리즘의 정당성 증명
#### 해결해야 할 문제가 간단할 때는 직간적으로 알고리즘을 설계할 수 있지만, 문제가 복잡해지면 문제를 제대로 해결하는지를 파악하기 어렵다. 이 장에서는 알고리즘의 증명을 위해 흐히 사용하는 기법을 다루게 된다.
## 5-2 수학적 귀납법과 반복문 불변식
* ### 수학적 귀납법
#### 첫번째 도미노가 쓰러지면 마지막 도미노 또한 당연히 쓰러진다는 것을 직관적으로 알 수 있듯이 수학적 귀납법은 반복적인 구조를 갖는 명제들을 증명하는데 유용하게 사용되는 기법이다.
1.**단계 나누기** : 증명하고 싶은 사실을 여러 단계로 나누다.(ex> 100개의 도미노를 하나씩 나눈다)
2. **첫 단계 증명** : 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.( ex> 첫 번째 도미노가 넘어짐을 보이는 과정)
3. **귀납 증명** : 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.(ex> 한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러짐을 보이는 과정)
* ### 반복문 불변식
#### 귀납법은 알고리즘의 **정당성**을 증명할 때 가장 유용하게 사용되는 기법이다. 귀납법을 이용해 알고리즘의 정당성을 증명할 때는 반복문 불변식(loop in-variant)라는 개념이 유용하게 쓰인다.
#### 반복문 불변식이란 반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건이다. 불변식을 이용해 반복문의 정당성을 다음과 같이 증명할 수 있다.
1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 다르게 말하면, 반복문 내용이 시작할 때 불변식이 성립했다면 내용이 끝날 때에도 항상 성립함을 보인다.
3. 반복문 종료시에 불변식이 성립하면 정답을 구했음을 보인다.

* ### 이진 탐색과 반복문 불변식
``` c++
// 필수 조건 : A는 오름차순으로 정렬되어 있다.
// 결과 : A[i-1] < x <= A[i]인 i를 반환한다.
// 이때 A[-1] = 음의 무한대, A[n] = 양의 무한대라고 가정한다.
int binsearch(const vector<int>& A, int x){
    int n = A.size();
    int lo = -1, hi = n;
    // 반복문 불변식 1 : lo < hi
    // 반복문 불변식 2 : A[lo] < x <= A[hi]
    // (*) 불변식은 여기서 성립해야 한다.
    while( lo + 1 < hi){
    int mid = (lo + hi) / 2;
    if(A[mid] < x)
        lo = mid;
    else
        hi = mid;
        // (**) 불변식은 여기서도 성립해야 한다.
    }
    return hi;
}
```
#### 이 코드에서 2가지 사실을 알 수 있다.
1. lo + 1 =hi : while문이 종료했으니 lo+1 >= hi 인데 불변식에 의하면 lo< hi 이니 lo+1 = hi 일 수 밖에 없다.
2. A[lo] < x < A[hi] : 애초에 불변식이 성립한다고 가정했으니 이것은 당연히 성립한다.
* ### 삽입 정렬과 반복문 불변식
삽입 정렬은 각 원소를 순서대로 고려하면서 이 원소를 앞에 있는 정렬된 부분 수열에 끼워넣는 작업을 반복하는 알고리즘이다.
``` c++
void insertionSort(vector<int>& A){
    for(int i=0; i< A.size(); ++i){
    // 불변식 a : A[0..i-1]은 이미 정렬되어 있다.
    // A[0..i-1]에 A[i]를 끼워넣는다.
    int j=i;
    while(j>0 && A[j-1] > A[j]){
    // 불변식 b: A[j+1..i]의 모든 원소는 A[j]보다 크다.
    // 불변식 c: A[0..i] 구간은 A[j]를 제외하면 정렬되어 있다.
    swap(A[j-1],A[j]);
    j--;
    }
    }
}
```
## 5-3 귀류법
#### 우리가 원하던 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법을 귀류법이라고 한다. 귀류법은 대개 어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용된다.
## 5-4 다른 기술들
* ### 비둘기집의 원리
10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면 반드시 2마리 이상이 들어간 비둘기집이 존재한다.
* ### 동전 뒤집기
100개의 동전중에서 x개의 동전을 한번에 뒤집고 모두 앞면이 나오게 하려면 최대 100이다. 101이 될 경우 앞면의 최대 개수가 100이기 때문에 중복이 발생하여 안된다. 이때 발생된 중복을 발생시키지 않는 것이 이 기술의 핵심이다.
* ### 구성적 증명
구성적 증명은 흔히 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해서 사용된다. 답의 실제 예를 들거나 답을 만드는 방법을 실제로 보이는 것이다.
ex> 하늘이 날 수 있는 물체를 보일 때 비행기를 만들어서 보여주거나 비행기를 만드는 법이 적힌 설명서를 보여 주는 것이다.
