# 03 코딩과 디버깅에 관하여
## 3-1 도입: 코딩의 중요성을 간과하지 말라
&nbsp; 프로그래밍 대회에서 성적을 올리는 가장 직접적인 요인은 무엇일까? 알고리즘이나 자료 구조 또한 중요한 지식이지만 코딩 능력이 가장 중요하다고 볼 수 있다.
## 3-2 좋은 코드를 짜기 위한 원칙
&nbsp; 프로그래밍 대회에서 코드를 작성할 때 첫 번째 원칙은 가장 간결한 코드를 작성하는 것이다. 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워지기 때문이다.
* 적극적으로 코드 재사용하기
&nbsp;간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드를 모듈화하는 것이다. 다시말해 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것이 좋다.(2~3번이상 같은 코드가 등장한다면 함수로 바꾸어라)
* 표준 라이브러리 공부하기
&nbsp; 프로그래밍 대회에서 모든 코드를 직접 짜는 것은 시간 낭비이다. 표준 라이브러리를 사용하여 시간을 줄일 수 있다( ex> 배열,스택,큐,리스트 등 자료 구조나 알고리즘을 표준 라이브러리로 사용해라)
* 일관적이고 명료한 명명법 사용하기
&nbsp; 함수명을 모호하게 하지마라! 변수 혹은 함수의 이름을 한눈에 알아볼수 있게 작성한다( int AddCircle 이런식으로 o , int a 는 x)
## 3-3 자주하는 실수
#### 산술 오버플로
&nbsp;가장 자주 발생하며 계산 과정에서 변수의 표현범위를 벗어나는 값을 사용하는 실수이다.
#### 배열 범위 밖 원소에 접근
&nbsp; c나 c++에서배열의 원소에 접근할 때 해당 인덱스가 배열 범위 안에 있는지를 별도로 확인해주지 않기 때문에 발생한다.
#### 일관되지 않은 범위 표현 방식 사용하기
&nbsp; 열린구간이나 닫힌구간 둘다 단점이 있기 때문에 그의 절충안인 반 열린 구간(half-open interval)을 사용한다.
#### Off-by-one 오류
&nbsp; 이 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류를 말한다. 반 열린 구간을 사용했을때 흔히 발생하는 오류인데
방지하려면 최소 입력이 주어졌을 때 이코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜야 한다.
&nbsp; ex) 길이가 100m 인 담장에 10m 간격으로 울타리 기둥을 세운다면 담장의 길이가 0m 일때도 기둥을 박아야 한다.(최소 입력은 0 을 가르킨다)
#### 컴파일러가 잡아주지 못하는 상수 오타
&nbsp; 변수명이나 함수명은 컴파일러가 잡아 주기 떄문에 크게 걱정하지 않는 경우가 많다. 입력부분에서 weird를 wierd로 출력하면 문제가 달라지고
0의 개수를 잘못 입력한 경우 등이 있기 때문에 자신이 사용하는 언어에서 상수의 타입을 어떻게 지정하는지,어느 형태로 강제되는지 미리 알아두는 것이 중요하다
#### 스택 오버플로
&nbsp; 프로그래밍 대회에서 재귀 호출을 사용할 일이 굉장히 많기 때문에 스택 오버플로를 유의해야 한다.  대회에서 사용하는 환경의 스택 허용량을 미리 알아두고
&nbsp; STL 컨테이너를 사용하거나 전역 변수를 사용하면 막을 수 있다.
#### 잘못된 비교 함수 작성
&nbsp; 최대 최소 예외 잘못 다루기 / 연산자 우선순위 잘못 쓰기(ex> & 와 ==의 우선순위) / 변수 초기화 문제
## 3-4 디버깅과 테스킹
* 디버깅에 관하여
&nbsp; 프로그램이 원하던 결과와 다를 경우 보통 디버거를 켜서 프로그램이 실행되는 과정을 하나하나 따라가 보는 것이 좋다. 하지만 디버거를 사용할 수 없는 경우 다음과 같은 단계를 생각한다.
1. 작은 입력에 대해 제대로 실행되나 확인하기: 예제 입력의 크기가 클 경우 프로그램의 실행 과정을 눈 만으로 하나하나 되짚어 가기 어렵다. 이럴 때는 오작동하는 가장 작은 입력을 찾아내면 디버깅하기 훨씬 용이하다.
2. 단정문(assertion)을 쓴다 : 단정문이란 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문을 의미한다. 주어진 조건이 참일 때는 무시되고 거짓일 때만 오류를 내므로 유용하게 쓸 수 있다.
3. 프로그램의 계산 중간 결과를 출력한다 : 프로그램이 실행되는 중간 과정 값들을 출력하고 이것이 자신이 예상하는 바와 맞는지 확인하면 오차를 줄일 수 있다.

## 3-5 변수 범위의 이해
*  산술 오버플로
&nbsp; 어떤 변수 n이 있다고 하면 이 변수에 담을 수 있는 숫자는 제한이 없다. 하지만 컴퓨터의 모든 변수에는 담을 수 있는 크기가 제한되어 있다. 따라서 수학적/논리적으로는 완전히 정당한 알고리즘도 프로그램으로 구현했을 때는 예상과 다른 결과를 보여줄 수 있다.
&nbsp; 이 문제를 일으키는 흔한 원인이 바로 산술 오버플로(arithmetic overflow)이다. 어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우를 말한다.
&nbsp; 오버플로를 막으려면 가장 간단한 방법으로 더 큰 자료형을 사용하는 것이다. 혹은 연산의 순서를 바꿔서 오버플로를 막을 수도 있다.
## 3-6 실수 자료형의 이해
* IEEE 754 표준(가장 많이 사용되는 실수 표기 방식은 IEEE 754 표준이라고 한다.)
  * 이진수로 실수를 표기
  * 부동 소수점(floating-point)표기법
  * 무한대,비정규 수(subnormal number), NaN(Not a Number : 숫자 아님) 등의 특수한 값이 존재
 1.실수의 이진법 표기
&nbsp; 실수를 이진법으로 쓰는 방법은 굉장히 간단하다. 소수점 밑 i번째 자리의 크기는 1/2^i가 된다.
 2. 부동 소수점 표기
&nbsp; 32비트의 공간을 이용해 실수를 이진법으로 표기한다고 하면 16비트는 정수부, 16비트는 소수부로 표현할 수 있을 것이다. 하지만 IEEE754를 고려하여 실수 표준에서는 소수점을 옮길 수 있게 했다. 정수부에 너무 많은 비트를 사용해 버리면 소수부의 정확도가 떨어지기 때문이다. 따라서 3가지의 정보를 저장하게 된다.


1. 부호 비트(sign bit) : 양수인지 음수인지 여부
2. 지수(exponent) : 소수점을 몇칸 옮겼나?
3. 가수(mantissa) : 소수점을 옮긴 실수의 최상위 X 비트
&nbsp; IEEE 754를 만든 사람들은 실수형에서 지수보다 가수에 훨씬 많은 비트 수를 부여하기로 결정했다. 지수는 소수점을 움직이는 횟수이기 때문에, 지수가 상대적으로 작더라도 거의 모든 숫자들을 표현할 수 있다.
&nbsp; 이렇게 소수점을 움직이는 실수 표기법을 부동 소수점(floating-point) 표기 방식이라고 한다.

*  실수 비교하기
&nbsp; 컴퓨터가 실수를 근사적으로 표현한다는 사실을 알고 나면 소스 코드에서 왜 원하던 답이 나오지 않았는 지를 이해할 수 있다.
&nbsp; 두 실수 값이 같은지를 비교할 때는 항상 어느 정도의 오차를 염두에 두어야 한다.

* 코드의 수치적 안정성 파악하기
&nbsp; 실수 변수를 사용하기가 얼마나 복잡한 일인지 알았을 거다. 하지만 수치적으로 안정적인 코드에서는 실수의 정확도 문제를 고려하지 않아도 된다.
&nbsp; 어떤 프로그램이 수치적으로 안정적(numerically stable)이라는 말은 프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다는 말이다.
(실행 중 한 연산 결과의 값이 0.00001 만큼 차이가 났는데, 프로그램이 모두 실행된 뒤 마지막 결과 값이 1789만큼 차이난다면 이것은 불안정하다고 말한다)


 > 찾아보기 : c++ 배열 / vector<>/ &주소값 / 오버로딩 라이딩 / (youtube) 찾은 후 정리 -- // 왜 vector <int> &을 사용하는지
