# 10 탐욕법
## 10-1 도입
#### 탐욕법(greedy method)은 직관적인 알고리즘 설계 패러다임 중 하나이다. 이것은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고, 각 단계마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색이나 동적 계획법 알고리즘과 다를 것이 없다. 그러나 모든 선택지를 고려해 보고 그중 전체 답이 가장 좋은 것을 찾는 두 방법과는 달리, 탐욕법은 각 단계마다 지금 가장 좋은 방법만을 선택한다.
탐욕적 알고리즘은 많은 경우 최적해를 찾지 못하기 때문에 다음과 같은 경우로 제한된다.
1. 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우,동적 계획법보다 수행 시간이 훨씬 빠르기 때문에 좋다.
2. 시간 or 공간적 제약으로 다른 방법의 최적해를 찾기가 어렵다면 최적해 대신 적당히 괜찮은 답(근사해)를 찾는 것으로 타협할 수 있다.
#### 탐욕적 알고리즘은 주로 대회에서 첫 번째 용도로만 사용된다.
* ### 예제: 회의실 예약
#### 탐욕법이 유용하게 사용되는 문제는 활동 선택 문제(activity selection problem)가 있다. n개의 팀이 회의하고 싶은 시간을 제출했을 때 회의실은 하나이고, 겹치지 않고 회의를 진행하는 경우는 몇일까? 우리가 원하는 가장 좋은 답은 곧 최적해는 크기가 가장 큰 부분 집합이다.
#### 탐욕적 알고리즘의 구상 : 가장 먼저 끝나는 회의부터 선택한다. 이것을 반복하는 알고리즘을 짠다.
1. 목록 S에 남은 회의 중 가장 일찍 끝나는 회의 S(min)을 선택한다.
2. S(min)과 겹치는 회의를 S에서 모두 지운다.
3. S가 텅 빌 때까지 반복한다.
### 정당성의 증명 : 탐욕적 선택 속성
#### 탐욕적 알고리즘의 정당성 증명은 많은 경우 일정한 패턴을 가진다. 이 증명 패턴은 탐욕적인 알고리즘이 항상 최적해를 찾아낼 수 있다는 것을 두가지의 속성을 증명함으로써 보인다. 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구하는 것을 탐욕적 선택 속성(greedy choice property)라고 부른다. 이것이 성립할 경우, 각 단계에서 탐욕적으로 내리는 선택은 항상 최적해로 가는 길 중 하나이다. 이는 다음과 같은 말을 의미한다.
 * 가장 종료 시간이 빠른 회의S(min)를 포함하는 최적해가 반드시 존재한다.
#### 최적 부분 구조 : 첫 번째 선택을 하고 나서 남은 부분 문제는 최적이 아닌 방법으로 풀어야 하는 경우가 있는데 이것을 최적 부분 구조(optimal substructure)이라고 부른다.
#### 구현 : 처음에 모든 회의를 종료 시간의 오름차순으로 정렬해 둔다.
```  c++
// 각 회의는 [begin,end) 구간 동안 회의실을 사용한다.
int n, begin[100],end[100];
int schedule() {
    // 일찍 끝나는 순서대로 정렬한다.
    vector<pair<int,int> order;
    for(int i=0; i<n; i++)
        order.push_back(make_pair(end[i],begin[i]));
    sort(order.begin(),order.end());
    // earliest : 다음 회의가 시작할 수 있는 가장 빠른 시간
    // selected : 지금까지 선택한 회의의 수
    int earliest=0, selected=0;
    for(int i=0;i<order.size();++i){
        int meetingBegin = order[i].second, meetingEnd = order[i].first;
        if(earliest <= meetingBegin) {
        //earliest를 마지막 회의가 끝난 시간 이후로 갱신한다.
        earliest = meetingEnd;
        ++selected;
        }
    }
    return selected;
}
```
* ### 예제 : 출전 순서 정하기(난이도 : 하)
#### 이 예제는 동적 계획법으로 접근 가능하지만 시간이 오래걸리기 때문에 탐욕적 알고리즘으로 설계한다. 맨 앞 경기부터 한 명씩 출전할 한국 선수를 정했을 때,상대방 선수를 이 길 수있는 한국 선수를 쭉 뽑은 다음, 그중 레이팅이 가장 낮은 선수를 경기시킨다. 만약 한국 선수 모두보다 레이팅이 높다면 가장 낮은 레이팅 선수를 보낸다.
#### 탐욕적 선택 속성 증명 : 최적해인지 판단할 때에는 귀류법을 통해 역을 가정해서 최적해를 만들어 보고 확인한다.
``` c++
// 출전 순서 정하기 문제를 해결하는 탐욕적 알고리즘
int order(const vector<int>& russian, const vector<int>& korean) {
    int n = russian.size(), wins =0;
    //아직 남아있는 선수들의 레이팅
    multiset<int> ratings(korean.begin(), korean.end());
    for(int rus =0;,rus<n;rus++) {
    // 가장 레이팅이 높은 한국 선수가 이길 수 없는 경우 가장 레이팅이 낮은 선수와 경기함
    if(*ratings.rbegin() < russian[rus])
        ratings.erase(ratings.begin());
    // 이 외의 경우 이길 수 있는 선수 중 가장 레이팅이 낮은 선수와 경깋나다.
    else {
        ratings.erase(ratings.lower_bound(russian[rus]);
        ++win;
    }
    }
    return wins;
}
```
* ### 탐욕적 알고리즘 레시피
1. 문제의 답을 만드는 과정을 여러 조각으로 나눈다.
2. 각 조각마다 어떤 우선순위로 선택을 내려야 할지 결정한다. 이에 대한 직관을 얻기 위해선 예제 입력이나 작은 입력을 몇개 손으로 풀어보는 것이 효율적이다.
3. 어떤 방식이 동작할 것 같으면 두 가지 속성을 증명해 보자.
    a) 탐욕적 선택 속성 : 항상 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재함을 보인다.
    b) 최적 부분 구조 : 각 단계에서 항상 최적의 선택만을 했을 때 전체 최적해를 구할 수 있는지 여부를 증명한다.
## 10-2 문제 : 도시락 데우기(난이도 : 하)
#### n개의 도시락을 주문한다고 하자. i번째 도시락을 데우는데 m초가 걸리고, 먹는데 e초가 걸린다고 할때 가장 빨리 점심시간을 마치는 프로그램을 작성해라.
## 10-3 풀이
#### 한 도시락을 먹을 때까지 걸리는 시간은 지금까지 데운 모든 도시락을 데우는 시간의 합에 이 도시락을 먹는데 걸리는 시간을 더한 것이다.
### 구현 : 오래 걸리는 도시락부터 데우는 것이 답이다.
``` c++
int n, e[MAX_N], m[MAX_N];
int heat() {
    // 어느 순서로 데워야 할지를 정한다.
    vector<pair<int,int>> order;
    for(int i=0; i<n; i++)
        order.push_back(make_pair(-e[i],i));
    sort(order.begin(),order.end());
    // 해당 순서대로 데워먹는 과정을 시물레이션한다.
    int ret=0;,beginEat=0;
    for(int i=0;i<n;i++){
        int box= order[i].second;
        beginEat += m[box];
        ret = max(ret, beginEat +e[box]);
    }
 return ret;
}
```