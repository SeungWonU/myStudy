# 08 동적 계획법
## 8-1 도입
#### 동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임 중 하나로, 이름만 가지고는 무엇을 의미하는지 알 수 없기 때문에 가장 많은 오해를 불러 일으키는 주제이기도 하다.
* ### 중복되는 부분 문제
#### 동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답으로부터 원래 문제에 대한 답을 계산해 내기 때문이다.
#### 동적 계획법과 분할 정복의 차이는 나누는 방식에 있다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 그러기 위해선 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이미 계산한 값을 저장해 두는 메모리를 캐시(cache)라고 하며 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems) 라고 부른다.
ex> abcdefg를 abcde와 cdefg로 분할 할 경우 재귀 호출을 이용해 풀면 중복하게 된다. 계산이 많을 때는 지수적으로 증가하기 때문에 어렵다. 이런 경우 동적 계획법 알고리즘을 사용하면 된다.
#### 동적 계획법 중 가장 유명한 예는 이항 계수(binomial coefficient)계산이다. 이항 계수는 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타낸다.
``` c++
// 재귀 호출을 이용한 이항 계수의 연산
int bino(int n,int r){
//기저 사례 : n=r(모든 원소를 다 고르는 경우) or r=0(고를 원소가 없을 경우)
if(r == 0 || n == r) return 1;
return bino(n-1,r-1) + bino(n-1,r);
}
```
#### 이 코드를 실행해 보면 중복 호출된다는 것을 알 수 있다. n과 r이 커짐에 따라 호출 수는 기하급수적으로 증가한다. 이 낭비를 피하기 위해 우리는 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 메모이제이션(memoization)이라는 것을 사용한다.
``` c++
// 메모이제이션을 이용한 이항 계수의 계산
// -1로 초기화해 둔다
int cache[30][30];
int bino2(int n, int r){
//기저 사례
if(r == 0 || n == r) return 1;
// -1이 아니라면 한 번 계산했던 값이니 곧장 반환
if(cache[n][r] != -1)
    return cache[n][r];
    //직접 계산한 뒤 배열에 저장
 return cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);
}
```
#### 메모제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소하는 것을 예상할 수 있다.
### 이와 같이 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.
* ### 메모이제이션을 적용할 수 있는 경우
#### 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 참조적 투명성(referential transparency)이라고 부른다. 또한 입력이 고정되어 있을 때 그 결과가 항상 같은 함수를 참조적 투명함수라고 부른다. 메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다. 입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없기 떄문이다.
* ### 메모이제이션 구현 패턴
#### 동적 계획법에 메모이제이션은 자주 구현하게 된다. 한 가지 패턴을 정해두고 같은 형태로 구현하기 때문에 버그를 찾기도 쉽다. 다음과 같은 재귀 함수가 있다고 가정하자
``` c++
// a와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### someObscureFunction()은 한 번 계산하는 데 굉정히 시간이 오래 걸리는 참조적 투명 함수라고 가정하자 아래 코드는 이 함수를 메모이제이션으로 어떻게 바꿔 구현하는지 보여준다.
> 주의점 : 항상 기저 사례를 먼저 처리한다.(아닌 경우 오류날 수도 있음) / 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화했다(cache의 해당 위치값이 -1이면 반환 값이 아니다) / ret가 cache[a][b]의 참조형이라는 걸 생각해라./memset()으로 cache[]를 초기화해라.
``` c++
//전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a 와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b){
// 기저 사례를 처음에 처리한다.
if(...) return...;
//(a,b)에 대한 답을 구한 적이 있으면 곧장 반환
int ret = cache[a][b];
if(ret != -1) return ret;
//여기에서 답을 계산한다.
...
return ret;
}
int main(){
//memset()을 이영해 cache 배열을 초기화한다.
memset(cache,-1,sizeof(cache));
}
```
#### 이 책의 모든 메모이제이션 코드들이 이 패턴을 따라 구성되어 있다.
* ### 메모이제이션의 시간 복잡도 분석
#### 메모이제이션의 시간 복잡도가 꾀나 헷갈릴 수 있다. 각 입력에 대해 함수를 처음으로 호출할 때와 다음으로 호출할 때 걸리는 시간이 다르기 때문이다. 그러나 굉장히 간단하게 계산할 수 있는 아래와 같은 방법이 있다.
> (존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
#### 위 식을 이항 계수를 계산하는 bino2()에 적용해 보면 r의 최대치는 n이니 부분 문제의 수는 최대 O(n^2)이다. 각 문제를 계산하는 시간은 반복문이 없으니 O(1)이다. 따라서 위 식에 대입하면 n^2 X 1 = O(n^2)가 된다.
* ### 예제 : 외발 뛰기(난이도 : 하)



> 2019/07/04(목) 243까지
