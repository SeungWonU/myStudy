# 08 동적 계획법
## 8-1 도입
#### 동적 계획법(dynamic programming)은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임 중 하나로, 큰 의미에서 분할 정복과 같은 접근 방식이다.
* ### 중복되는 부분 문제
#### 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답으로부터 원래 문제에 대한 답을 계산해 내기 때문이다.
#### 동적 계획법과 분할 정복의 차이는 나누는 방식에 있다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 그러기 위해선 각 문제의 답을 메모리에 저장해 두어야 하는데 이미 계산한 값을 저장해 두는 메모리를 캐시(cache)라고 하며 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems) 라고 부른다.
ex> abcdefg를 abcde와 cdefg로 분할 할 경우 재귀 호출을 이용해 풀면 중복하게 된다. 계산이 많을 때는 지수적으로 증가하기 때문에 어렵다. 이런 경우 동적 계획법 알고리즘을 사용하면 된다.
#### 동적 계획법 중 가장 유명한 예는 이항 계수(binomial coefficient)계산이다. 이항 계수는 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타낸다.
``` c++
// 재귀 호출을 이용한 이항 계수의 연산
int bino(int n,int r){
//기저 사례 : n=r(모든 원소를 다 고르는 경우) or r=0(고를 원소가 없을 경우)
if(r == 0 || n == r) return 1;
return bino(n-1,r-1) + bino(n-1,r);
}
```
#### 이 코드를 실행해 보면 중복 호출된다는 것을 알 수 있다. n과 r이 커짐에 따라 호출 수는 기하급수적으로 증가한다. 이 낭비를 피하기 위해 우리는 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 메모이제이션(memoization)이라는 것을 사용한다.
``` c++
// 메모이제이션을 이용한 이항 계수의 계산
// -1로 초기화해 둔다
int cache[30][30];
int bino2(int n, int r){
//기저 사례
if(r == 0 || n == r) return 1;
// -1이 아니라면 한 번 계산했던 값이니 곧장 반환
if(cache[n][r] != -1)
    return cache[n][r];
    //직접 계산한 뒤 배열에 저장
 return cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);
}
```
#### 메모제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소하는 것을 예상할 수 있다.
### 이와 같이 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.
* ### 메모이제이션을 적용할 수 있는 경우
#### 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 참조적 투명성(referential transparency)이라고 부른다. 또한 입력이 고정되어 있을 때 그 결과가 항상 같은 함수를 참조적 투명함수라고 부른다. 메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다. 입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없기 떄문이다.
* ### 메모이제이션 구현 패턴
#### 동적 계획법에 메모이제이션은 자주 구현하게 된다. 한 가지 패턴을 정해두고 같은 형태로 구현하기 때문에 버그를 찾기도 쉽다. 다음과 같은 재귀 함수가 있다고 가정하자
``` c++
// a와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### someObscureFunction()은 한 번 계산하는 데 굉정히 시간이 오래 걸리는 참조적 투명 함수라고 가정하자 아래 코드는 이 함수를 메모이제이션으로 어떻게 바꿔 구현하는지 보여준다.
> 주의점 : 항상 기저 사례를 먼저 처리한다.(아닌 경우 오류날 수도 있음) / 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화했다(cache의 해당 위치값이 -1이면 반환 값이 아니다) / ret가 cache[a][b]의 참조형이라는 걸 생각해라./memset()으로 cache[]를 초기화해라.
``` c++
//전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a 와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b){
// 기저 사례를 처음에 처리한다.
if(...) return...;
//(a,b)에 대한 답을 구한 적이 있으면 곧장 반환
int ret = cache[a][b];
if(ret != -1) return ret;
//여기에서 답을 계산한다.
...
return ret;
}
int main(){
//memset()을 이영해 cache 배열을 초기화한다.
memset(cache,-1,sizeof(cache));
}
```
#### 이 책의 모든 메모이제이션 코드들이 이 패턴을 따라 구성되어 있다.
* ### 메모이제이션의 시간 복잡도 분석
#### 메모이제이션의 시간 복잡도가 꾀나 헷갈릴 수 있다. 각 입력에 대해 함수를 처음으로 호출할 때와 다음으로 호출할 때 걸리는 시간이 다르기 때문이다. 그러나 굉장히 간단하게 계산할 수 있는 아래와 같은 방법이 있다.
> (존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
#### 위 식을 이항 계수를 계산하는 bino2()에 적용해 보면 r의 최대치는 n이니 부분 문제의 수는 최대 O(n^2)이다. 각 문제를 계산하는 시간은 반복문이 없으니 O(1)이다. 따라서 위 식에 대입하면 n^2 X 1 = O(n^2)가 된다.
* ### 예제 : 외발 뛰기(난이도 : 하)
#### nxn 크기의 격자에 1~9까지 정수를 쓴 게임판이 있다. 이때 게임의 목적은 게임판의 왼쪽 위 칸에서 시작하여 게임판의 맨 오른쪽 아래 칸에 도착하는 것이다. 각 칸에 적혀 있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며 중간에 게임판 밖으로 벗어나면 안된다. 문제는 게임판이 주어질 때 시작점에서 끝점으로 도달하는 방법이 존재하는지를 확인하는 것이다.
#### 재귀호출에서 시작하기 : 동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 완전 탐색은 시작점에서 모든 경로를 하나씩 만들어 마지막 칸에 도달할 수 있는지를 검사한다. 다음과 같은 재귀 함수를 만들어 보자.
jump(y,x) = (y,x)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.
#### jump()는 한 번 호출될 때마다 아래로 갈지 오른쪽으로 갈지 선택하면 된다. 게임판의 (y,x) 위치에 있는 수를 jumpSize라고 하면, 아래로 뛸 경우 jump(y+jumpSize,x) 이고 오른쪽으로 뛸 경우 jump(y,x+jumpsSize)로 표현할 수 있다.
#### 따라서 jump(y,x) = jump(y+jumpSize,x) || jump(y,x+jumpSize) 가 된다. 이것을 코드로 구현할 경우
``` c++
int n, board[100][100];
bool jump(int y, int x){
// 기저 사례 : 게임판 밖을 벗어난 경우
if(y >= n || x >= n) return false;
//기저 사례 : 마지막 칸에 도착한 경우
if(y == n-1 && x == n-1) return true;
int jumpSize = board[y][x];
return jump( y+ jumpSize,x) || jump(y,x+jumpSize);
}
```
* ### 메모이제이션 적용하기
#### 위의 코드의 문제는 이 문제에 답이 존재하지 않아도 완전 탐색이기 때문에 수없이 많은 경로들을 일일이 탐색한다. 이것을 방지하기 위해 jump2()를 만들었는데 이것은 불린 값을 반환하는 것이 아니라 정수를 반환한다. 불린 값은 캐시를 사용하게 되면 계산 된것인지 알 수 없기 떄문이다. 1or0 의 정수를 반환하기로 약속하면 -1로 초기화한 정수형 배열을 캐시로 사용할 수 있다.
다음 코드를 살펴보자
``` c++
int n,board[100][100];
int cache[100][100];
int jump2(int y, int x) {
//기저 사례 처리
if(y >= n || x >= n) return 0;
if(y == n-1 && x == n-1) return 1;
//메모이제이션
int & ret = cache[y][x];
if(ret != -1) return ret;
return ret = (jump2(y + jumpSize, x) || jump2(y, x +jumpSize));
}
```
* ### 동적 계획법 레시피
#### 1. 주어진 문제를 완전 탐색을 이용해 해결한다.
#### 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.
## 8-2 문제 : 와일드카드(난이도 : 중)
#### 와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 저장하는 방법이다. 이때 사용하는 문자열을 와일드카드 패턴이라고 하는데, 패턴은 일반적인 파일명과 비슷하지만 특수 문자 *나 ?를 포함할 수 잇는 문자열이다. 와일드카드 패턴을 앞에서 한 글자씩 파일명과 비교해서 모든 글자가 일치했을 때 와일드카드 패턴이 파일명과 대응된다고 말한다. 단, 패턴에 포함된 ? 는 어떤 글자와도 대응된다고 가정하며, *은 0 글자 이상의 어떤 문자열에도 대응된다고 가정하자. 예를 들어 와일드카드 he?p는 파일명 help 에도, heap 에도 대응되지만 helpp 에는 대응되지않는다. 반면 와일드카드 *p* 는 파일명 help에도, papa에도 대응되지만 hello에는 대응되지 않는다.
문제 : 와일드카드 패턴과 함께 파일명의 집합이 주어질 때, 그중 패턴에 대응되는 파일명들을 찾아내는 프로그램을 작성해라.
#### 내 풀이
``` c++
int wildCard( string pattern, string testWord ){
// 기저 사례1 : pattern 의 첫 글자가 '?' 이면 재귀 호출하여 넘어감( substr(1)을 하여 첫 글자를 제거함)
if(pattern[0] == '?') return ret;
// 기저 사례2 : pattern 의 첫 글자가 '*' 이면   둘다 제거 > 다음 단어
if(pattern[0] == '*') {
string k; //k== * 다음에 오는 문자
pattern[1] == k;
pattern[0].substr(1);   //*을 지운다.
 for(int i=0;i< testWord.length();i++)
      {
      if( testWord[i] == k )
           {  if( i==0 ) return ret; //  이 경우는 pattern 이 *k 이고  testWord 가 k 일때 발생한다.
           for(int j=0;j<= i-1;j++)
                   { testWord.substr(j)  }  // k앞의 수들을 전부 지운다.
            }
       }
return ret; // 지금 상태는 둘다 0번째가 똑같이 k이다.
}
return 0; // testWord 의 각 단어를 살펴봤는데 k와 일치한게 없기 때문
// 기저 사례3 : 글자가 서로 다르면 false
if(pattern[0] != testWord[0]) return 0;
// 기저 사례4 : 첫 글자가 존재하지 않으면 끝( 문자열의 길이가 0이면)
if(pattern.length == 0) return 1;
// 첫 번째 요소를 제거하고 재귀 호출함
if(ret != -1) return ret;
return ret = wildCard( pattern.substr(1),testWord.substr(1) );
}
```
## 8-3 풀이 : 와일드카드
#### 이 문제를 어렵게 만드는 것은 *가 몇 글자에 대응되어야 하는지 알 수 없다는 점이다. 단순하게는 * 다음에 출현하는 글자가 나올 때까지 대응시킬수 있다만 *bb* 같은 예제를 해결할 수 없다. 이럴때 가장 쉬운 방법은 완전 탐색이다.
#### 주어진 패턴이 m개의 *을 포함한다고 해보자. 이 패턴을 * 가 나올때 마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌 수 있다.
#### 이 책에서는 한 글자씩 대응할 때 while문을 통해 '?' 가 나오거나 두 글자가 같으면 배열의 인덱스를 증가시킨다. 나처럼 재귀 호출을 바로하지 않음. 그리고 나서 *을 만나거나 둘 중 한문자열이 끝나면 멈춘다. 종료에 대해 더 자세히 살펴보면
w를 와일드카드, s를 원문, pos는 각 배열 인덱스 값 이라고 할때
1. s[pos]와 w[pos]가 대응되지 않는다 : 무조건 실패
2. w 끝에 도달했다 : 패턴에 *이 하나도 없을 경우이다. 이 경우엔 두 문자열 길이가 서로 같아야만 true 이다.
3. s 끝에 도달했다 : 패턴이 남았지만 문자열이 끝난경우에는 실패이지만 예외가 있다.(예외 : 남은 패턴이 전부 *로 구성되어 있으면 true)
4. w[pos]가 * 인 경우 : *가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사한다( 난 이부분을 for 문으로 작성)
이때 w의 pos+1이후를 패턴 w`로 하고, s의 pos+skip 이후를 문자열 s`로 해서 match(w`,s`)로 재귀 호출했을 때 답이 하나라도 존재하면 true 이다.
* ### 중복되는 부분 문제
#### 이 알고리즘은 일부 예제 입력의 경우에는 너무 오랜 시간이 걸릴 수 있다는 문제가 있다. 완전 탐색은 각 *에 대응되는 글자 수의 모든 조합을 검사하는데 문자열 길이가 길어지거나 *수가 많아지면 경우의 수가 늘어난다.
이 프로그램의 중복을 없애기 위해 캐시를 이용하여 프로그램을 훨씬 빠르게 할 수 있다. 패턴과 문자열의 길이가 모두 n이라고 할 때, 부분 문제의 개수는 n^2이다. 최대 n번의 재귀 호출을 하기 떄문에 O(n^3)이 된다.
* ### 다른 분해 방법
#### 다른 방법으로 이 문제를 O(n^2)시간에 풀 수 있다. 방금 전 풀이 방법에서 재귀 함수에 반복문이 있기 때문에 오래걸리게 되는데 반복문이 재귀 함수 자체에 하나도 없을 경우 시간을 줄일 수 있다. 방금 전 풀이에서는 while문을 사용하여 두 글자가 같거나 '?'이 나올경우 1씩 증가함을 나타냈는데 if문과 재귀 호출로 충분히 나타낼 수 있다.
``` c++
if(W[w] == '*') {
if(matchMemoized(w+1, s)  || (s < S.size() && matchMemoized(w,s+1))
        return ret = 1;
}
```
## 8-4 전통적 최적화 문제들
#### 동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제란 여러 개의 가능한 답 중 가장 좋은 답을 찾아내는 문제를 말한다. 최적화 문제를 동적 계획법으로 푸는 것 또한 완전 탐색에서 시작한다만,최적화 문제에 특정 성질이 성립할 경우 단순한 메모제이션을 적용하기보다 좀더 효율적으로 동적 계획법을 구현할 수 있다.
* ### 예제 : 삼각형 위의 최대 경로(난이도 : 하)
#### 삼각형 모양으로 배치된 자연수들이 있다.(직각 삼각형) 맨 위의 숫자에서 시작해서 아래로 내려가 맨 아래 줄까지 닿는 경로를 만드는데 한 칸 내려갈때 오른쪽아래 혹은 바로 아래 숫자로 내려갈 수 있다. 모든 경로 중 숫자의 합을 최대화하는 경로는 무엇일까? 최대의 합을 구하여라
#### 완전 탐색으로 시작하기 : 경로를 각 가로줄로 조각 낸 뒤, 각 조각에서는 아래로 내려갈지 오른쪽으로 내려갈지 선택하면서 모든 경로를 만든다. 이 때 재귀 호출 함수에는 현재 위치와 지금까지 만난 숫자들의 합을 전달하도록 한다. 그러면 아래와 같은 부분 문제를 얻을 수 있다.
pathSum( y, x, sum ) = 현재 위치가 (y,x)이고, 지금까지 만난 수의 합이 sum 일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환한다.
#### 아래쪽으로 내려갓을 때와 오른쪽으로 내려갔을 때의 최대 합을 각각 path()를 이용하여 점화식을 구해보자.
path1(y,x,sum) = max -> path(y+1,x,sum+triangle[y][x]) //아래쪽
path1(y,x,sum) = max -> path(y+1,x+1,sum+triangle[y][x]) // 오른쪽아래
#### 무식하게 메모이제이션 적용하기 : 방금 전 점화식은 답을 구하기 위해선 모든 경로를 다 만들어 봐야 한다는 문제가 있다.
//의문점 : 227p 코드 8.8에서 cache [MAX_NUMBER]이게 왜 메모리가 크다는거죠? 배열의 크기가 커진다고 문제가 발생하나? / if(ret != -1) return ret; 이거에서 return ret이 재귀함수 도는거 맞지?헷갈림..
* #### 입력 걸러내기
#### 이 알고리즘을 더 빠르게 하는 힌트는 재귀 함수의 입력을 다음과 같이 두 부류로 나누면 알 수 있다.
1.y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정한다.
2.sum은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다.
#### 다시 말하면 (y,x)는 아직 해결하지 못한 조각들의 입력이고, sum은 이미 결정한 조각들의 정보이다.
//궁금점 : 228p sum을 재귀 함수에 입력으로 받지 않도록 하면 왜 알고리즘이 빨라짐? for문이나 엄청 느리게 하는 요소가 있나?
* #### 이론적 배경 : 최적 부분 구조
#### 이렇게 sum이라는 정보가 (y,x)에서 맨 아래줄까지 내려가는 문제를 푸는데 아무런 상관이 없는데 이것을 최적 부분 구조(optimal substructure)이라고 부른다. 최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건을 말한다. 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 이 조건이 성립한다. 반면 더 작은 문제의 최적해만으로는 전체 문제의 최적해를 구할 수 없다면 해당 문제에는 최적 부분 구조가 존재하지 않는다라고 말한다.
* ### 예제 : 최대 증가 부분 수열(난이도 : 하)
#### 정수 수열 S의 부분 수열이란 S에서 0개 이상의 숫자를 지우고 남은 수열을 말한다. 예를 들어 '1 2 4'는 ' 1 5 2 4 7'의 부분 수열이다. 부분 수열에 포함된
숫자들이 순 증가(strictly increasing)하면 이 부분 수열을 증가 부분 수열이라고 한다. 예를 들어 '1 3 4 2 4'에서 '1 2 4'는 증가 부분 수열이지만 '1 4 4'는 아니다
증가 부분 수열 중 가장 긴 것을 찾는 문제를 최대 증가 부분 수열(LIS,Longest Increasing Subsequence)찾기 문제라고 부르며 매우 유명한 동적 계획법 중 하나이다.
* #### 완전 탐색에서 시작하기
#### LIS를 숫자 하나씩으로 조각낸 뒤, 한 조각에서 숫자 하나씩 선택하는 알고리즘을 만들어 보자.
수열 A를 입력받아 LIS의 길이를 반환하는 재귀 함수 lis(A)는, A의 모든 증가 부분 수열을 만든 뒤 그중 가장 긴 것의 길이를 반환한다.
* #### 입력 손보기
> 의문점 : 232p 입력이 정수가 아니라 정수의 배열이기 떄문에 메모이제이션을 사용하기 까다롭다?? /234 233 모르겠음..(8.11코드에서 236p의 2번이 어떻게 적용되는지)
* #### 더 빠른 해법
#### 사실 이 O(n^2) 알고리즘은 가장 빠른 방법이 아니다. O(nlgn)에 LIS를 찾을 수 있는 알고리즘이 존재한다. 이것은 텅 빈 수열에서 시작해 숫자를 하나씩 추가해 나가며 각 길이를 갖는 증가 수열 중 가장 마지막 수가 작은 것은 무엇인지를 추적한다. 예를 들어 S의 첫 다섯 원소가 {5,6,7,1,2}라고 해보자. LIS는 길이가 3인 {5,6,7} 하나밖에 없다. 반면 길이가 2인 LIS는 3개가 있다. 이 중에서 1,2와 5,6을 비교해 보면 1,2뒤에는 3이나 4가 주어질 경우 추가될 수 있지만 5,6뒤에는 붙지 못한다. 따라서 1,2처럼 증가 부분 수열 중 최소의 마지막 값이어야 O(nlgn)이 성립하게 된다.
* #### 최적화 문제 동적 계획법 레시피
#### 다음은 최적화 문제의 동적 계획법을 설계하기 위한 과정을 정리한 것이다.
1. 모든 답을 만들어 보고 그중 최적해의 점수를 반환하는 완전 탐색 알고리즘을 설계해라.
2. 전체 답의 점수를 반환하는 것이 아니라, 앞으로 남은 선택들에 해당하는 점수만을 반환하도록 부분 문제 정의를 바꾸자.
3. 재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 필요한 것을 제외하고 없앤다. 만약 문제에 최적 부분 구조가 성립하면 모든 정보를 없앨 수도 있다.여기서 우리의 목적은 가능한 중복되는 부분 문제를 많이 만드는 것이다.
4. 입력이 배열이거나 문자열이면 가능한 메모이제이션을 사용하라.
## 8-5 문제 : 합친 LIS(난이도 : 하)
#### 두 개의 정수 수열 A와 B에서 각각 길이 0 이상의 증가 부분 수열을 얻은 뒤 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 한다. 이 중 가장 긴 수열을 합친 LIS 라고 한다. A와 B가 주어질 때, 합친 LIS 의 길이를 계산하는 프로그램을 작성해라.
> 의문점 : 236에서  13479은 194와 347 을 예시로 들었는데 194는 증가 부분 수열이 아닌데 왜 예시로 들었지?
## 8-6 풀이
#### 이 문제는 LIS의 확장판 이다. 수열 S의 최대 증가 부분 수열을 찾는 재귀 함수 lis3()의 정의는 다음과 같다.
> lis3(start) 는 S[start]에서 시작하는 최대 증가 부분 수열의 길이
## 8-7 문제 : 원주율 외우기 : (난이도 : 하)
* ### 구현
#### 이 문제를 푸는 완전 탐색 알고리즘은 주어진 수열을 쪼개는 모든 방법을 하나씩 만들어 보며 그중 난이도 합이 가장 작은 조합을 찾아낸다. 각 재귀함수는 한 번 불릴 때마다 첫 조각의 길이를 하나하나 시도하며 남은 수열을 쪼갠다. 따라서 부분 수열의 시작위치 begin이 주어질 때 최소 난이도를 반환하는 함수 memorize()를 다음과 같이 정의할 수 있다.
memorize(begin) = min(memorize(begin+L) + classify(N begin,L))
#### 여기서 N begin,L은 N[begin]에서 싲가하는 길이 L인 부분 문자열이고, classify()는 해당 조각의 난이도를 반환하는 함수이다. 이번 코드에는 난이도를 판정하는 classify()와 실제 메모이제이션을 구현하는 memorize()로 나뉜다.

## 8-9 문제 : Quantization(난이도 : 중)
#### Quantization(양자화) 과정은, 더 넓은 범위를 갖는 값들을 작은 범위를 갖는 값들로 근사해 표현함으로써 자료를 손실 압축하는 과정이다.
## 8-10 풀이
* ### 하던 대로는 안 된다
#### 주어진 수열 A의 첫 번째 숫자를 어떤 숫자로 표현할 것인지를 결정하고,나머지 수열에 대해 재귀 호출로 문제를 해결한다.
quantize(A) = A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합
quantize(A,U) = U가 지금까지 한 번 이상 사용한 숫자들의 집합일 때 A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합
#### 답의 형태 제한하기 : 부분 문제의 개수가 너무 많을 때 방법은 어떤 구조를 가질 것이라고 예측하고 그것을 강제하는 것이다. 여기서는 비슷한 크기의 수들끼리 묶음을 분할하고 묶음을 한 숫자로 표현해서 오류를 최소화한다.
## 8-11 경우의 수와 확률
#### 동적 계획법은 최적화 문제를 풀기 위해 고안되었지만 경우의 수 or 확률 문제도 사용된다.경우의 수에 재귀적인 특징이 사용되기 때문이다.
#### 오버플로에 유의하기 : 보통 경우의 수를 세는 문제는 입력의 크기에 대해 답은 지수적으로 증가한다.
* ### 예제 : 타일링 방법의 수 세기
#### 2xn 크기의 사각형을 2x1 크기의 타일로 채우는 방법의 수를 계산하는 문제이다. 타일은 겹치면안되고 회전가능하다.(n<100)
#### 우선 완전 탐색을 이용해 답을 만든 뒤, 메모이제이션을 이용해 동적 계획법 알고리즘으로 바꿔보자. 재귀 호출을 이용해 모든 타일링 방법을 만드려면 각 타일링 방법을 여러 조각으로 조개고 하나씩 만들어 가면 된다. 이 타일링 문제는 왼쪽 세로줄 부터 채우게 되는데 세로타일 하나만 덮을 것인지 가로타일 두개로 덮을 것인지를 결정한다. 남은 공간은 2x(n-1), 2x(n-2)크기가 되고 재귀 호출로 계산한다.
따라서 다음 과 같은 형태의 부분 문제가 된다.
> tiling(n) = 2xn 크기의 사각형을 타일로 덮는 방법을 반환한다.  / tiling(n) = tiling(n-1) + tiling(n-2)
* ### 경우의 수 계산 레시피
1. 모든 답을 직접 만들어 완전 탐색 알고리즘을 설계한다. 이때 경우의 수를 제대로 세기 위해서는 재귀 호출의 각 단계에서 고르는 선택지에 이 속성이 성립해야한다.
    a)모든 경우는 이 선택지들에 포함됨
    b)어떤 경우도 두 개 이상의 선택지에 포함되지 않음
2. 최적화 문제를 해결할 때처럼 이전 조각에서 결정한 요소들에 대한 입력을 없애거나 변형해 줄인다. 재귀 함수는 앞으로 남아있는 조각들을 고르는 경우에만 반환한다.
3. 메모이제이션을 적용한다.
## 8-12 비대칭 타일링(난이도 : 하)
#### 위의 타일링 수 세기 문제와 같지만 좌우대칭되는 것은 세지 않는다.
* ### 내풀이 : 이전 타일링의 수를 구하는 코드에 비대칭 단계를 추가한다.
``` c++
const int MOD = 100000007;
int cache[101];
int firstWidth; ( 처음 제시한 사각형의 길이)
int width= firstWidth;
int tiling(width){
// 기저 사례 : width가 1이하 일때
// 3가지 기저 사례를 추가한다
// 1. firstWidth가 짝수일때  n/2과 n/2+1을 기준으로 하여 양옆이 대칭일때
//2. firstWidth가 짝수일때 1~n/2와 n/2+1~n 까지가 대칭일때
//3. firstWidth가 홀수이고 n/2+1을 기준사각형으로 양옆이 대칭일때
if(width<=1)
    if((firstwidth % 2 ==0) && tiling(firstWidth/2 -1))
//여기서 문제는 tiling()이거는 수를 반환하기때문에 내가 원하는 한쪽의 그림을 구할수가 없음..
//새로운 함수를 만들어서 지금까지 지나온 경로를 만든다.
//기준점 반대편도 만들면 되는데 대칭은 거울처럼 봐야하는데 대칭하는 코드를 모르겠다.
}
```
## 8-13 풀이
## 8-14 폴리오미노(난이도 : 중)
#### 정사각형들의 변들을 서로 완전하게 붙여 만든 도형을 폴리오미노(Polyomino)라고한다.이 중 세로로 단조(monotone)인 폴리오미노의 수가 몇 개나 되는지 세고 싶다.(세로로 단조는 어떤 가로줄로 2번이상 교차하지 않는 것이다.)
* ### 내풀이
``` c++
int move;//움직인 횟수
int poly(int y, int x){
move++;
if(
//기저사례: n번 움직였으면 끝
if(move== n) return 1;
int& ret =  cache[y][x];

// 캐쉬에서 y+1줄에있는 모든 x값을 비교해보면서 중복된값이 있을시 ( 지금 자리 양옆 제외하고 ) false;
return ret=for(int i=0;i<move;i++)if(cache[y+1][i] != -1 && i !=x+1 && i != x+1 )return false; ploy(y+1,x);//위
+ for(int i=0;i<move;i++)if(cache[y-1][i] != -1 && i !=x+1 && i != x+1 )return false; ploy(y-1,x);//아래
 + ploy(y,x+1); //오른
 + ploy(y,x-1); //왼
}
```
//궁금 :ret !=-1로 쓸수는없나?
//벌써 틀린점 : 같은 모양이 나오는걸 생각못했다..좌표로 지정했기때문에 캐쉬에 저장해도 안될거같음? 내나름대로 재귀호출과 캐쉬를 썼지만 중요한건 강제하여 푸는것!
## 8-15 풀이
* ### 나처럼 경우의 수를 일일이 따지면 완전 탐색이 된다. 구하기 너무 많아서 세로단조를 중요시한다!!
## 8-16 두니발 박사의 탈옥(난이도 : 중)
####
``` c++
int N; // 마을의 수
int D; // 일 수
int A[50][50];
int T;// 확률을 계산할 마을의 수
int start , finish[T]; // 시작점, 끝점
//day는 현재 날짜 arrive는 다음 목적지
int k = 1;// 확률값을 곱해줌
int runAway(int day,int start,int arrive) // 지금 시작점에서 도착점으로 도달했을때 확률값 반환한다. 재귀 호출을 통해 반환값을 곱한다. 끝까지 가서 원하는 날 원하는 목적지에 도달했으면 지금까지 곱한 확률값을 반환.
//시작할때는 day값과 start값만 넣어줌
//day==D가 되고 지금 해당하는 점이 finish[T]안에 포함되면 true
if(day==D )
    {for(int i=0;i<T;i++)
        {if(arrive ==  finish[i])
        return ret;}
        return 0;
    }
int denom=0; // 분모
for(int arrive=0;arrive<N;arrive++)
    { if(A[start][arrive]==1) denom++;}
//기저사례 : 현재 시작점에서 갈곳이 없을때
if(denom == 0)
    return 0;
return 1/denom;
//재귀호출
for(star=0;star<Day;star++)
{ k = runAway(day+1,star) ;
  multiply *=k;

  k = 0;
}

```
>  273p 코드 ret /= deg[path[i]]가 확률까지 다계산됨 내가 필요했던 부분 & vector로 push,pop하는거 해야 하나 다끝내고 새거할때 필요
#### 275 코드에서  here == q ? 1.0 : 0.0 이렇게 간단하게 쓸수있는거 참고!!
#### 이문제 핵심 :search2(here,days) 는 두니발 박사가 days일째에 here번 마을에 숨어있을 때 마지막 날에 q번 마을에 있을 조건부 확률을 반환한다.

## 8-17 풀이
###
* #### 번외 : 해밀턴 회로(Hamiltonian cycle)란 어떤 그래프에서 모든 꼭지점을 단 한번만 지나는 회로를 의미한다. 어떤 그래프에서 해밀턴 경로가 존재하는 지 여부를 묻는 문제는 NP-완전문제에 속한다. 또한 꼭지점을 한번만 지나는데 출발점으로 돌아오는 것을 해밀턴패쇠라고 한다.
* #### 번외 : 오일러 회로란 어떤 그래프에 존재하는 모든 간선을 정확히 한 번씩만 방문하는 연속된 경로를 말한다(시작점과 도착점이 같으면 회로, 다르면 경로) ex> 한 붓 그리기