# 08 동적 계획법
## 8-1 도입
#### 동적 계획법은 프로그래밍 대회 문제에 가장 자주 출현하는 디자인 패러다임 중 하나로, 이름만 가지고는 무엇을 의미하는지 알 수 없기 때문에 가장 많은 오해를 불러 일으키는 주제이기도 하다.
* ### 중복되는 부분 문제
#### 동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답으로부터 원래 문제에 대한 답을 계산해 내기 때문이다.
#### 동적 계획법과 분할 정복의 차이는 나누는 방식에 있다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 속도의 향상을 꾀할 수 있다. 그러기 위해선 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이미 계산한 값을 저장해 두는 메모리를 캐시(cache)라고 하며 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems) 라고 부른다.
ex> abcdefg를 abcde와 cdefg로 분할 할 경우 재귀 호출을 이용해 풀면 중복하게 된다. 계산이 많을 때는 지수적으로 증가하기 때문에 어렵다. 이런 경우 동적 계획법 알고리즘을 사용하면 된다.
#### 동적 계획법 중 가장 유명한 예는 이항 계수(binomial coefficient)계산이다. 이항 계수는 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타낸다.
``` c++
// 재귀 호출을 이용한 이항 계수의 연산
int bino(int n,int r){
//기저 사례 : n=r(모든 원소를 다 고르는 경우) or r=0(고를 원소가 없을 경우)
if(r == 0 || n == r) return 1;
return bino(n-1,r-1) + bino(n-1,r);
}
```
#### 이 코드를 실행해 보면 중복 호출된다는 것을 알 수 있다. n과 r이 커짐에 따라 호출 수는 기하급수적으로 증가한다. 이 낭비를 피하기 위해 우리는 함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 메모이제이션(memoization)이라는 것을 사용한다.
``` c++
// 메모이제이션을 이용한 이항 계수의 계산
// -1로 초기화해 둔다
int cache[30][30];
int bino2(int n, int r){
//기저 사례
if(r == 0 || n == r) return 1;
// -1이 아니라면 한 번 계산했던 값이니 곧장 반환
if(cache[n][r] != -1)
    return cache[n][r];
    //직접 계산한 뒤 배열에 저장
 return cache[n][r] = bino2(n-1,r-1) + bino2(n-1,r);
}
```
#### 메모제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장할 수 있기 때문에 함수 호출 횟수가 엄청나게 감소하는 것을 예상할 수 있다.
### 이와 같이 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.
* ### 메모이제이션을 적용할 수 있는 경우
#### 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 참조적 투명성(referential transparency)이라고 부른다. 또한 입력이 고정되어 있을 때 그 결과가 항상 같은 함수를 참조적 투명함수라고 부른다. 메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다. 입력이 같은데도 외부 요소에 따라 다른 값이 반환된다면 캐싱을 할 수가 없기 떄문이다.
* ### 메모이제이션 구현 패턴
#### 동적 계획법에 메모이제이션은 자주 구현하게 된다. 한 가지 패턴을 정해두고 같은 형태로 구현하기 때문에 버그를 찾기도 쉽다. 다음과 같은 재귀 함수가 있다고 가정하자
``` c++
// a와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### someObscureFunction()은 한 번 계산하는 데 굉정히 시간이 오래 걸리는 참조적 투명 함수라고 가정하자 아래 코드는 이 함수를 메모이제이션으로 어떻게 바꿔 구현하는지 보여준다.
> 주의점 : 항상 기저 사례를 먼저 처리한다.(아닌 경우 오류날 수도 있음) / 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화했다(cache의 해당 위치값이 -1이면 반환 값이 아니다) / ret가 cache[a][b]의 참조형이라는 걸 생각해라./memset()으로 cache[]를 초기화해라.
``` c++
//전부 -1로 초기화해 둔다.
int cache[2500][2500];
// a 와 b는 각각 [0,2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b){
// 기저 사례를 처음에 처리한다.
if(...) return...;
//(a,b)에 대한 답을 구한 적이 있으면 곧장 반환
int ret = cache[a][b];
if(ret != -1) return ret;
//여기에서 답을 계산한다.
...
return ret;
}
int main(){
//memset()을 이영해 cache 배열을 초기화한다.
memset(cache,-1,sizeof(cache));
}
```
#### 이 책의 모든 메모이제이션 코드들이 이 패턴을 따라 구성되어 있다.
* ### 메모이제이션의 시간 복잡도 분석
#### 메모이제이션의 시간 복잡도가 꾀나 헷갈릴 수 있다. 각 입력에 대해 함수를 처음으로 호출할 때와 다음으로 호출할 때 걸리는 시간이 다르기 때문이다. 그러나 굉장히 간단하게 계산할 수 있는 아래와 같은 방법이 있다.
> (존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
#### 위 식을 이항 계수를 계산하는 bino2()에 적용해 보면 r의 최대치는 n이니 부분 문제의 수는 최대 O(n^2)이다. 각 문제를 계산하는 시간은 반복문이 없으니 O(1)이다. 따라서 위 식에 대입하면 n^2 X 1 = O(n^2)가 된다.
* ### 예제 : 외발 뛰기(난이도 : 하)
#### nxn 크기의 격자에 1~9까지 정수를 쓴 게임판이 있다. 이때 게임의 목적은 게임판의 왼쪽 위 칸에서 시작하여 게임판의 맨 오른쪽 아래 칸에 도착하는 것이다. 각 칸에 적혀 있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며 중간에 게임판 밖으로 벗어나면 안된다. 문제는 게임판이 주어질 때 시작점에서 끝점으로 도달하는 방법이 존재하는지를 확인하는 것이다.
#### 재귀호출에서 시작하기 : 동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 완전 탐색은 시작점에서 모든 경로를 하나씩 만들어 마지막 칸에 도달할 수 있는지를 검사한다. 다음과 같은 재귀 함수를 만들어 보자.
jump(y,x) = (y,x)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.
#### jump()는 한 번 호출될 때마다 아래로 갈지 오른쪽으로 갈지 선택하면 된다. 게임판의 (y,x) 위치에 있는 수를 jumpSize라고 하면, 아래로 뛸 경우 jump(y+jumpSize,x) 이고 오른쪽으로 뛸 경우 jump(y,x+jumpsSize)로 표현할 수 있다.
#### 따라서 jump(y,x) = jump(y+jumpSize,x) || jump(y,x+jumpSize) 가 된다. 이것을 코드로 구현할 경우
``` c++
int n, board[100][100];
bool jump(int y, int x){
// 기저 사례 : 게임판 밖을 벗어난 경우
if(y >= n || x >= n) return false;
//기저 사례 : 마지막 칸에 도착한 경우
if(y == n-1 && x == n-1) return true;
int jumpSize = board[y][x];
return jump( y+ jumpSize,x) || jump(y,x+jumpSize);
}
```
* ### 메모이제이션 적용하기
#### 위의 코드의 문제는 이 문제에 답이 존재하지 않아도 완전 탐색이기 때문에 수없이 많은 경로들을 일일이 탐색한다. 이것을 방지하기 위해 jump2()를 만들었는데 이것은 불린 값을 반환하는 것이 아니라 정수를 반환한다. 불린 값은 캐시를 사용하게 되면 계산 된것인지 알 수 없기 떄문이다. 1or0 의 정수를 반환하기로 약속하면 -1로 초기화한 정수형 배열을 캐시로 사용할 수 있다.
다음 코드를 살펴보자
``` c++
int n,board[100][100];
int cache[100][100];
int jump2(int y, int x) {
//기저 사례 처리
if(y >= n || x >= n) return 0;
if(y == n-1 && x == n-1) return 1;
//메모이제이션
int & ret = cache[y][x];
if(ret != -1) return ret;
return ret = (jump2(y + jumpSize, x) || jump2(y, x +jumpSize));
}
```
 > 궁금한점 : 다시 첨부터 시작을 어떻게함? 이 코드는 시작점에서 끝점까지 가는 경로 한번인데 /  ||이거를 쓰는데  조건이 없는경우 그걸 사용하면 보통 앞에부터 써지는지
* ### 동적 계획법 레시피
#### 1. 주어진 문제를 완전 탐색을 이용해 해결한다.
#### 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.
## 8-2 문제 : 와일드카드(난이도 : 중)
#### 와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 저장하는 방법이다. 이때 사용하는 문자열을 와일드카드 패턴이라고 하는데, 패턴은 일반적인 파일명과 비슷하지만 특수 문자 *나 ?를 포함할 수 잇는 문자열이다. 와일드카드 패턴을 앞에서 한 글자씩 파일명과 비교해서 모든 글자가 일치했을 때 와일드카드 패턴이 파일명과 대응된다고 말한다. 단, 패턴에 포함된 ? 는 어떤 글자와도 대응된다고 가정하며, *은 0 글자 이상의 어떤 문자열에도 대응된다고 가정하자. 예를 들어 와일드카드 he?p는 파일명 help 에도, heap 에도 대응되지만 helpp 에는 대응되지않는다. 반면 와일드카드 *p* 는 파일명 help에도, papa에도 대응되지만 hello에는 대응되지 않는다.
문제 : 와일드카드 패턴과 함께 파일명의 집합이 주어질 때, 그중 패턴에 대응되는 파일명들을 찾아내는 프로그램을 작성해라.
#### 내 풀이
``` c++
int wildCard( string pattern, string testWord ){
int cache [100];
int &ret = cache[y][x];

// 기저 사례1 : pattern 의 첫 글자가 '?' 이면 재귀 호출하여 넘어감( substr(1)을 하여 첫 글자를 제거함)
if(pattern[0] == '?') return ret;
// 기저 사례2 : pattern 의 첫 글자가 '*' 이면   둘다 제거 > 다음 단어
if(pattern[0] == '*') {
string k; //k== * 다음에 오는 문자
pattern[1] == k;
pattern[0].substr(1);   //*을 지운다.

 for(int i=0;i< testWord.length();i++)
      {
      if( testWord[i] == k )
           {  if( i==0 ) return ret; //  이 경우는 pattern 이 *k 이고  testWord 가 k 일때 발생한다.
           for(int j=0;j<= i-1;j++)
                   { testWord.substr(j)  }  // k앞의 수들을 전부 지운다.
            }
       }
return ret; // 지금 상태는 둘다 0번째가 똑같이 k이다.
}
return 0; // testWord 의 각 단어를 살펴봤는데 k와 일치한게 없기 때문
// 기저 사례3 : 글자가 서로 다르면 false
if(pattern[0] != testWord[0]) return 0;
// 기저 사례4 : 첫 글자가 존재하지 않으면 끝( 문자열의 길이가 0이면)
if(pattern.length == 0) return 1;
// 첫 번째 요소를 제거하고 재귀 호출함
if(ret != -1) return ret;
return ret = wildCard( pattern.substr(1),testWord.substr(1) );
}
```
#### 궁금점: cache는 int를 써야하는데 string에서도 가능? 내가 쓴게 맞는지( ret = -1) /번외 : while문은 시간복잡도가 어떻게 되는지/ *bb*이거 내 풀이로 되지않나? / 이 해답도 help가 끝나면 다음 heap으로 어떻게 넘어가는지?
#### 오답 : 길이가 다르면 풀이가 틀린다.
## 8-3 풀이 : 와일드카드
#### 이 문제를 어렵게 만드는 것은 *가 몇 글자에 대응되어야 하는지 알 수 없다는 점이다. 단순하게는 * 다음에 출현하는 글자가 나올 때까지 대응시킬수 있다만 *bb* 같은 예제를 해결할 수 없다. 이럴때 가장 쉬운 방법은 완전 탐색이다.
#### 주어진 패턴이 m개의 *을 포함한다고 해보자. 이 패턴을 * 가 나올때 마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌 수 있다.
#### 이 책에서는 한 글자씩 대응할 때 while문을 통해 '?' 가 나오거나 두 글자가 같으면 배열의 인덱스를 증가시킨다. 나처럼 재귀 호출을 바로하지 않음. 그리고 나서 *을 만나거나 둘 중 한문자열이 끝나면 멈춘다. 종료에 대해 더 자세히 살펴보면
w를 와일드카드, s를 원문, pos는 각 배열 인덱스 값 이라고 할때
1. s[pos]와 w[pos]가 대응되지 않는다 : 무조건 실패
2. w 끝에 도달했다 : 패턴에 *이 하나도 없을 경우이다. 이 경우엔 두 문자열 길이가 서로 같아야만 true 이다.
3. s 끝에 도달했다 : 패턴이 남았지만 문자열이 끝난경우에는 실패이지만 예외가 있다.(예외 : 남은 패턴이 전부 *로 구성되어 있으면 true)
4. w[pos]가 * 인 경우 : *가 몇 글자에 대응될지 모르기 때문에, 0 글자부터 남은 문자열의 길이까지를 순회하며 모든 가능성을 검사한다( 난 이부분을 for 문으로 작성)
이때 w의 pos+1이후를 패턴 w`로 하고, s의 pos+skip 이후를 문자열 s`로 해서 match(w`,s`)로 재귀 호출했을 때 답이 하나라도 존재하면 true 이다.

> 의문점 : 코드 8.6 if(pos == w.size()) return pos == s.size();에서 return 하면 아예 bool 이 끝남? 아니면 다음 if 문으로 넘어감? pos 에 s.size 넣는 것도 이해가 안됨
* ### 중복되는 부분 문제
#### 이 알고리즘은 일부 예제 입력의 경우에는 너무 오랜 시간이 걸릴 수 있다는 문제가 있다. 완전 탐색은 각 *에 대응되는 글자 수의 모든 조합을 검사하는데 문자열 길이가 길어지거나 *수가 많아지면 경우의 수가 늘어난다.
이 프로그램의 중복을 없애기 위해 캐시를 이용하여 프로그램을 훨씬 빠르게 할 수 있다. 패턴과 문자열의 길이가 모두 n이라고 할 때, 부분 문제의 개수는 n^2이다. 최대 n번의 재귀 호출을 하기 떄문에 O(n^3)이 된다.
> 꺠달음 : cache 땜에 int 형으로 써야되는데  w 와 s를 굳이 문자열로 할 필요가 없다. 둘이 같은지,다른지만 비교해서 넘어가면 되므로 0과 1로 충분히 해결 할 수있고 ++로 다음 인덱스로 넘길 수 있다.
> 의문점 : 코드 8.7에 뒷장 if(w == W.size()) return ret = 이거도 위랑 비슷한 질문
* ### 다른 분해 방법
#### 다른 방법으로 이 문제를 O(n^2)시간에 풀 수 있다. 방금 전 풀이 방법에서 재귀 함수에 반복문이 있기 때문에 오래걸리게 되는데 반복문이 재귀 함수 자체에 하나도 없을 경우 시간을 줄일 수 있다. 방금 전 풀이에서는 while문을 사용하여 두 글자가 같거나 '?'이 나올경우 1씩 증가함을 나타냈는데 if문과 재귀 호출로 충분히 나타낼 수 있다.( 이건 내풀이에서 했음 하지만 내 풀이에서는 *을 for문으로 작성해서 실패! )   *은 이렇게 나타내면 된다.
``` c++
if(W[w] == '*') {
if(matchMemoized(w+1, s)  || (s < S.size() && matchMemoized(w,s+1))
        return ret = 1;
}
```
 이와 같이 하면 시간 복잡도는 O(n^2)가 된다.
## 8-4 전통적 최적화 문제들
#### 동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제란 여러 개의 가능한 답 중 가장 좋은 답을 찾아내는 문제를 말한다. 최적화 문제를 동적 계획법으로 푸는 것 또한 완전 탐색에서 시작한다만,최적화 문제에 특정 성질이 성립할 경우 단순한 메모제이션을 적용하기보다 좀더 효율적으로 동적 계획법을 구현할 수 있다.
* ### 예제 : 삼각형 위의 최대 경로(난이도 : 하)
####











> 2019/07/04(목) 243까지
* #### 번외 : 해밀턴 회로(Hamiltonian cycle)란 어떤 그래프에서 모든 꼭지점을 단 한번만 지나는 회로를 의미한다. 어떤 그래프에서 해밀턴 경로가 존재하는 지 여부를 묻는 문제는 NP-완전문제에 속한다. 또한 꼭지점을 한번만 지나는데 출발점으로 돌아오는 것을 해밀턴패쇠라고 한다.
* #### 번외 : 오일러 회로란 어떤 그래프에 존재하는 모든 간선을 정확히 한 번씩만 방문하는 연속된 경로를 말한다(시작점과 도착점이 같으면 회로, 다르면 경로) ex> 한 붓 그리기