# 07 분할 정복
## 7-1 도입
#### 분할 정복(Divide Conquer)은 가장 유명한 알고리즘 디자인 패러다임으로, 각개 격파라는 말로 간단히 설명 할 수 있다. 하나의 알고리즘을 둘 이상의 부분 문제로 나눈 뒤 각 문제를 재귀 호출로 푸는 방식이다. 일반적인 재귀 호출은 문제를 한 조각과 나머지 전체로 쪼개는 것이고 분할 정복은 비슷한 크기의 부분 문제로 나눈다.
분할 정복 알고리즘에는 3가지 요소가 있다.
1. 문제를 더 작은 문제로 분할하는 과정(divide)
2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge)
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)
* ### 예제 : 수열의 빠른 합과 행렬의 빠른 제곱
#### 수열의 합 6장의 예제(recursiveSum())에서 1+2+3+4+...+n = fastSum()이라고 하면 분할 정복으로 계산할 경우 fastSum(n) = 2*fastSum(n/2)+ n^2/4가 된다.
아래는 이것을 코드로 나타내었는데 홀수 부분도 주의깊게 봐야한다.
``` c++
// 필수조건 : n은 자연수
// 1+2+..+n을 반환한다
int fastSum(int n){
//기저 사례
if(n==1) return 1;
if(n % 2 == 1) return fastSum(n-1) +n;
return 2*fastSum(n/2) + (n/2)*(n/2);
}
```
* ### 시간복잡도 분석
#### 방금 본 fastSum()을 분할 정복으로 푼 것과 일반적인 재귀 호출로 푼 경우 시간이 다르다. O(n) 과 O(lgn)이다.
* ### 행렬의 거듭제곱
#### NxN 크기 A의 m 거듭제곱인 경우 행렬의 곱셈이 O(n^3)이기 때문에 O(n^3 * m) 이 된다.이는 시간이 오래걸리지만 분할 정복일 경우 얘기가 다르다.
A^m = A^(m/2) * A^(m/2) 로 해결하면 시간이 단축된다.
``` c++
// 정방행렬을 표현하는 SquareMatrix 클래스가 있다고 가정하자
class SquareMatirx;
// n*n 크기의 항등행렬을 반환하는 함수
SquareMatirx identity(int n);
//A^m을 반환한다.
SquareMatrix pow(const SquareMatirx&A, int m){
//기저 사례 : A^0 =1
if(m==0) return identity(A.size()));
if(m % 2>0) return pow(A,m-1) * A;// 홀수일때
SquareMatirx half = pow(A, m/2);
return half * half;
}
```
* ### 나누어 떨어지지 않을 때의 분할과 시간 복잡도
#### 방금 전 예제를 보면 홀수 부분에서 홀수를 무작정 절반으로 나누냐 or 홀수에서 1을뺴고 짝수로 만드냐 문제가 있는데 
무작정 나눌경우  ex) A^31 은 16,15로 쪼개진다. 16은 8로 15는 8,7로 쪼개지는데 8이 중복된다 진행될수록 중복되는 함수가 많아져 시간이 더 오래걸리게 된다.
따라서 분할 정복이더라도 부분 문제가 중복(overlapping)되는 문제를 삼가해야 한다.
* ### 예제 : 병합정렬과 퀵 정렬
#### 주어진 수열 크기 순서대로 정렬하는 것과 분할 정복 패러다임을 기반으로 해서 만든 대표적인 것은 병합 정렬(Merge sort)과 퀵 정렬(Quick sort)이다. 병합 정렬은 수열을 가운데에서 쪼개 비슷한 크기의 수열 두개로 만든 뒤 이들을 재귀호출해 각각 정렬한다. 반대로 퀵 정렬은 병합 과정이 필요 없도록 한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록 배열한다. 이를 위해 퀵 정렬은 파티션(partition)단계를 도입한다. 이는 배열에 있는 수 중에서 기준(pivot)을 지정한 후 정렬하는 것이다.
#### 병합 정렬의 분할은 굉장히 단순하다(O(1)) 하지만 병합 단계에서 시간이 많이 걸린다(O(n))
#### 퀵은 분할하는데 O(n)걸리지만 병합 작업이 필요없다는 장점이 있다. 이를 이용해 알고리즘을 구현하자
* ### 시간 복잡도 분석
#### 병합 정렬은 병합에 필요한 총 시간이 O(n)이고 분할될때 항상 절반으로 되기 때문에 O(lgn)이므로 O(nlgn)이다.
#### 퀵 정렬은 항상 비슷한 크기로 나눌 수 없다. 택한 원소가 최대이면 크기가 하나씩 줄어들기 때문에 이런 최악의 경우 O(n^2)이 된다. 거의 절반 정도로 나눠지면 O(nlgn)으로 병합정렬과 같다.
## 7-2 문제 : 쿼드 트리 뒤집기(난이도 : 하)
#### 대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해 사용하는 여러 기법 중 쿼드 트리(quad tree)라는 것이 있다. 주어진 공간을 항상 4개로 분할해 재귀적으로 표현하기 때문에 쿼드 트리라는 이름이 붙었다.
1. 그림의 모든 픽셀이 검은 색일 경우 결과는 b가 된다.
2. 그림의 모든 픽셀이 흰 색일 경우 결과는 w가 된다.
3. 모든 픽셀이 같은 색이 아닐경우, 쿼드 트리는 그림을 4등분하여 압축한다.
문제 : 쿼드 트리로 압축된 흑백 그림이 주어졌을 때, 이 그림을 상하로 뒤집은 그림을 쿼드 트리 압축해서 출력하는 프로그램으 작성해라.
## 7-3 풀이 : 쿼드 트리 뒤집기
#### 이 문제를 풀 수 있는 가장 무식한 방법은 주어진 그림의 쿼드 트리 압축을 풀어서 실제 이미지를 얻고 상하 반전한 뒤 다시 압축하는  것이다.
#### 쿼드 트리가 재귀적으로 정의되어 있기 때문에 쿼드 트리를 압축하거나 해제하는 과정은 재귀 호출로 구현하는 것이 가장 자연스럽다. 문자열 s의 압축을 해제해서 NxN 크기의 배열에 저장하는 함수 decompress()를 구현한다고 하자. 기저 사례는 s의 첫 글자가 w나 b 인 경우이다. 만약 첫 글자가 x라면 decompress()는 s의 나머지 부분을 넷으로 쪼개 재귀 호출합니다.
``` c++
char decompressed[MAX_SIZE][MAX_SIZE];
//s를 압축 해제해서 decompressed[y..y+size-1][x..x+size-1] 구간에 쓴다.
void decompress(const string &s, int y, int x, int size);
```
* ### 압축 문자열 분할하기
#### 주어진 위치에서 시작하는 압축 결과의 길이를 반환하는 함수 getChunkLength()를 만든다. s[0]이 x라고 하면, 왼쪽 위 조각을 나타내는 부분은 항상 s[1]에서 시작한다. 이때 getChunkLength(s,1)이 해당 부분 압축의 길이를 반환하도록 한다.
getChunkLength(s,1)이 5를 반환하면 다음 조각은 s[6]부터 시작하는 것을 알 수 있다.
``` c++
char decompressed[MAX_SIZE][MAX_SIZE];
void decompress(string::iterator& it, int y, int x, int size){
// 한 글자를 검사할 때마다 반복자를 한 칸 앞으로 옮긴다.
char head = *(it++);
//기저 사례 : 첫 글자가 b또는 w인 경우
if(head == 'b' || head == 'w'){
    for(int dy=0; dy<size ; ++dy)
        for(int dx=0;dx<size; ++dx)
            decompressed[y+dy][x+dx] = head;
}
else{
    // 네 부분을 각각 순서대로 압축 해제한다.
    int half = size/2;
    decompress(it,y,x,half);
    decompress(it, y, x+half, half);
    decompress(it,y+half,x,half);
    decompress(it,y+half,x+half,half);
}
}
```
## 7-4 문제: 울타리 잘라내기(난이도 :중)
#### 너비가 같은 N개의 나무판자를 붙여 세운 울타리가 있다. N개의 울타리에서 일부를 직사각형으로 잘라내 재활용하려고 한다. 잘라 낼 수 잇는 직사각형의 최대 크기를 구하여라.(단, 비스듬히는 잘라낼 수 없다.)//판자의 너비는 모두 1이라고 가정
> 내 풀이
7개의 나무 판자가 있다고 가정하면 1번의 나무 판자를 가장 큰 직사각형(LargeRec)으로 가정한다. 그 다음 1,2번을 보고 가로가 2이고 높이는 두 막대중 최소인 것을 찾는다.그 넓이를 LargeRec이랑 비교한다 더 큰것을 LargeRec으로 함
이렇게 7번까지 해서 제일 큰 값을 LargeRec 으로 정한다.(3번째일 경우 1,2,3 / 2,3 / 3의 경우를 해본다) (4는 1,2,3,4 / 2,3,4/ 3,4 /4)
> 단점 : 시간이 너무 오래걸림 ( 무식하기 풀기의 풀이와 비슷함 O(n^2)이 걸리는데 판자의 수가 20000이므로 1초안에 실행할 수 없음) 2중for문인 것은 가로도 n번 세로도 n번으로 찾아야 하기 때문
#### (양쪽 부분 문제에 걸친 경우) 우선 가운데에 선을 긋고 직사각형을 옆으로 한 칸씩 확대 해 나간다. 그렇다면 왼쪽 오른쪽 두 경우가 있는데 둘 중 직사각형의 높이가 긴 곳으로 먼저 옮직임
이렇게 확장해 나아가면서 넓이를 반환한다. 끝까지 나아가면 이 중 최대 넓이를 반환하게 된다.
``` c++
//각 판자의 높이를 저장하는 배열
vector<int> h;
// h[left..right]구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환한다.
int solve(int left, int right){
// 기저 사례 : 판자가 하나밖에 없는 경우
if(left == right) return h[left];
//[left,mid],[mid+1,right]의 두 구간으로 문제를 분할한다.
int mid = (left+right)/ 2;
//분할한 문제를 각개 격파
int ret = max(solve(left,mid), solve(mid+1,right));
// 부분 문제 3 :두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다.
int lo = mid, hi = mid+1;
int height = min(h[lo],h[hi]);
//[mid,mid+1]만 포함되는 너비 2인 사각형을 고려한다.
ret = max(ret,height*2);
//사각형이 입력 전체를 덮을 때까지 확장해 나간다.
while(left < lo || hi <right){
// 항상 높이가 더 높은 쪽으로 확장한다.
if(hi<right && (lo == left || h[lo-1]< h[hi+1])) {
++hi;
height = min(height, h[hi]);
}
else {
--lo;
height = min(height,h[lo]);
}
//확장한 후 사각형의 넓이
ret = max(ret, height* (hi-lo+1));
}
return ret;
}
```
#### 풀이를 본 결과 분할 정복 알고리즘을 제대로 사용함(막상 풀때는 분할을 못할 것 같았는데 사용 가능) but 풀이 중 한가지 이해되지않음
> 우리가 구하려는 가장 큰 직사각형이 왼쪽과 오른쪽 부분에 걸쳐 있을 경우엔 이 풀이가 완벽하다. 하지만 왼쪽에만 치우쳐 있거나 오른쪽에만 치우쳐있을 경우 재귀 호출하여 해결하면 된다고 하였다.
그런데 컴퓨터는 문제를 보고 가장 큰 직사각형이 사이에 걸쳐있는지 오른쪽에 치우쳐 있는지 모른다. ~질문~ 또 있다 ex> 3개의 판자가 있는데 하나가 다른 두 개에 비해 훨씬 크다. 그렇다면 그 판자 하나가 정답인데 이 문제에서는 직선을 접하는 두개의 직사각형의 면적을 기준으로 하기 때문에 오류? 또 재귀함수는 시간복잡도가 어케되지?

## 7-6 문제 : 팬미팅(난이도 :상)
#### 혼성 아이돌 그룹이 팬미팅을 개최하였다. N명의 멤버들은 일렬로 무대에 서고 M명의 팬들은 줄서서 오른쪽부터 한명씩 왼쪽으로 움직이며 포옹을 한다. 남자 팬과 남자 멤버는 포옹대신 악수를 하기로 하였다. 한번에 모든 멤버가 다 포옹할 경우는 얼마인가?
> 내 풀이
#### 혼성그룹을 배열 group[n] / 팬들을 벡터 vector<m> fans 로 정의한다. poOng (포옹) 함수를 만들고 전체 멤버가 포옹할 때마다 num 값을 1증가. 마지막에 num 값을 출력한다.
#### poOng 함수를 재귀함수로 만든다. fans 에서 (m-n)번 pop.back 을 하여 뒤에 요소를 제거한다. 그러면 fans와 group의 수를 같게 할 수 있다. 다음 for(int i=0;i<n;i++) if(group[i]==M && fans[i]==M) return false;
이말은 멤버 n명과 팬 n명 중에서 한 짝이라도 둘다 남자가 있을 시 false를 반환한다. false 가 안되면 num +1로 포옹횟수가 올라간다. 마지막은 재귀함수 하기전에 fans 의 멤버가 한 칸씩 왼쪽으로 가기 때문에 fans.substr(1);을 하여 맨 앞 요소를 없앤다.
이것을 재귀함수로 반복하면 해결
> 궁금한 점 : 내풀이가 203p에 있는 단순한 방법으로 푼 문제인가? 아니면 아예 다르게 풀었나?
#### 하지만 이 책에서는 카라츠바 알고리즘으로 구현하였다.( 내가 한 풀이는 시간이 오래걸림..좋은 답이 아니다.)
#### 카라츠바의 빠른 곱셈 알고리즘을 살펴보면 분할 정복 알고리즘의 한 예이다.(Karatsuba) 카라츠바는 두개의 정수를 곱하는 알고리즘이다. 수백자리나 수만자리의 큰 수들을 다룰 때 주로 사용한다.
#### 이것의 장점은 A[i] 와 B[i]를 곱한 결과를 C[i+j]에 저장하는 등 훨씬 직관적인 코드를 작성할 수 있다.
