# 04 알고리즘의 시간 복잡도 분석
## 4-1 도입
#### 좀더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 알고리즘의 속도를 어떻게 측정할지를 정하는 것이다. 만약 속도를 측정할 수 없다면 알고리즘을 바꿨을 때 이것이 더 빠른지 느린지를 알 수 없기 때문이다.
#### 두 알고리즘의 속도를 비교하는 가장 직관적인 방법은 두 프로그램의 수행 시간을 측정하는 것이다. 하지만 프로그램의 실행 시간은 알고리즘의 속도를 일반적으로 이야기하는 기준이 되기에는 부적합하다.
#### 가장 큰 이유는 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제 등 수많은 요소들에 의해 바뀔 수 있기 때문이다. 또한 프로그램의 수행 시간이 다양한 입력에 대해 실행 시간을 반영하지 못한다는 것이다.
#### 알고리즘은 언제나 같은 속도로 동작하는 것이 아니라 입력의 크기나 특성에 따라 같은 알고리즘이라 해도 수행 시간이 달라질 수 있다.
그렇다면 알고리즘의 수행 시간을 어떤 기준으로 측정해야 할까?
* ### 반복문이 지배한다
#### 보통 한가지 항목이 전체의 대소를 좌지우지하는 것을 지배한다(dominate)라고 하는데 알고리즘의 수행 시간을 지배하는 것은 바로 반복문이다.

이 코드를 보면 N번 수행되는 반복문이 두 개 겹쳐져 있으므로, 반복문의 가장 안쪽은 항상 N^2번 실행된다. 따라서 이 알고리즘의 수행 시간은 N^2이다.
``` c++
//주어진 배열 A 에서 가장 많이 등장하는 숫자를 반환한다.
//만약 두 가지 이상 있을 경우 아무거나 반환한다.
int majority1(const vector<int>& A){
int N = A.size();
int majority = -1, majorityCount =0;
for(int i=0; i<N; i++){
//A에 등장하는 A[i]의 수를 센다.
int V = A[i], count=0;
for(int j=0;j<N;j++){
if(A[j]== V)
    ++count;
}

//지금까지 본 최대 빈도보다 많이 출현했다면 답을 갱신한다.
if(count > majorityCount){
majorityCount = count;
majority = V;
}
}
return majority;
}
```

## 4-2 선형 시간 알고리즘
* ### 다이어트 현황 파악 ; 이동 평균 계산하기
#### 입력의 크기에 대비해 걸리는 시간의 그래프가 직선인 경우 우리는 이런 알고리즘을 선형 시간(linear time)알고리즘이라고 부른다. 선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다.(수행 시간이 N에 정비례한다.)
## 4-3 선형 이하 시간 알고리즘
#### 어떤 문제를 모두 한 번 훑는데 걸리는 시간은 선형 시간이 걸린다. 그렇다면 선형 시간보다 빠르게 동작하려면 입력된 자료를 다 보지도 않고 실행한다는 말인데 이런 알고리즘이 존재할까?
#### 존재한다. (ex> 10만장의 사진 중에 사람이 있는 사진을 찾는 문제일 경우 10만장을 일일이 찾는 경우도 있겠지만 절반으로 나누어서 5만번째 사진을 확인해보고 또 절반,또 그의 절반을 확인해 나아가면 된다)
#### N을 계속 절반으로 나눠서 1 이하가 될 때까지 몇 번이나 나눠야 하는지 알 수 있는데, 이것을 로그(log)라고 한다.(밑이 2인 로그)  이와 같이 입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘을 선형 이하 시간(sublinear time)알고리즘이라고 한다.
* ### 이진 탐색
#### 방금 전 예제에서 보여준 알고리즘을 이진 탐색(binary search)라고 한다.(전화번호부 혹은 사전을 찾을 때 흔히 사용한다) 이진 탐색 알고리즘이 하는 일을 다음과 같이 정의할 수 있다.
> binsearch(A[],x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1] < x < A[i]인 i를 반환한다. (이때 A[-1] = -infinity, A[N] = infinity로 가정한다)
#### 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환하는 것이다. 대개의 배열이나 리스트 구현에서 i번째 위치에 새 원소를 삽입한다는 것은 i번째와 그 이후 원소들을 뒤로 한 칸씩 밀어내고 들어간다는 뜻이다.
## 4-4 지수 시간 알고리즘
* ### 다항 시간 알고리즘
#### 변수 N의 거듭제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 하고 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라고 한다.
* ### 지수 시간 알고리즘
#### N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들은 지수 시간(exponential time)에 동작한다고 말할 수 있다. 지수 시간은 가장 큰 수행 시간 중 하나로, 입력의 크기에 따라 다항 시간과는 비교도 안 되게 빠르게 증가한다.
* ### 소인수 분해의 수행 시간
#### 입력으로 주어지는 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달라지는 알고리즘들 또한 지수 수행 시간을 가질 수 있다.
## 4-5 시간 복잡도
#### 시간 복잡도(time complexity)란 가장 널리 사용되는 알고리즘의 수행 시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 하수로 표현한 것입니다.(기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산이다)
ex> 두 부호 있는 32비트 정수의 사칙연산 / 두 실수형 변수의 대소 비교 / 한 변수에 다른 변수 대입하기
예가 아닌것 (반복문을 포함하기 때문에 기본적인 연산이 아니다!!)
ex> 정수 배열 정렬하기 / 두 문자열이 서로 같은지 확인하기 / 입력된 수 소인수 분해하기
#### 시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미이다.하지만 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아니다(입력의 크기가 충분히 작을 때는 시간 복잡도가 높은 알고리즘이 더 빠르게 동작할 수도 있다)
* ### 입력의 종류에 따른 수행 시간의 변화
#### 입력의 크기 뿐 아니라 형태 또한 수행 시간에 영향을 미친다.(최선.최악의 경우 평균적인 경우에 따라 각각 수행 시간이 다르다)
1. 최선의 수행 시간 : 찾으려는 원소가 배열의 맨 앞에 있을 때 알고리즘은 1번 실행하고 종료된다. 따라서 수행 횟수는 1이다.
2. 최악의 수행 시간 : N번 끝까지 반복하고 종료한다. 따라서 수행 횟수는 N이다.
3. 평균적인 수행 시간 : N/2이다.
> 보통 최악의 수행 시간을 사용한다.
* ### 점근적 시간 표기 : O 표기
#### O 표기법(Big-O Notation)이라는 것은 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법이다.(시간 복잡도를 계산하기 어렵기 떄문에 이것을 만들었다.)
ex> 3N^2 +4N +8 이면 N^2만 떼어내고 쓸때는 O(n^2)이라고 표기한다.
* ### 시간 복잡도 분석 연습
#### selectionSort()는 선택 정렬(selection sort) 알고리즘을 구현한다. 모든 i에 대해 A[i..N-1]에서 가장 작은 원소를 찾은 뒤, 이것을 A[i]에 넣는 것을 반복한다.
> 최대 O(N)번 실행되는 for 문이 두 개 겹쳐 있기 때문에 최종 시간 복잡도는 O(N^2)이다. (최악과 최선의 경우의 시간 복잡도가 같다)
#### insertionSort()는 삽입 정렬(insertion sort) 알고리즘을 구현한다. 전체 배열 중 정렬되어 있는 부분 배열에 새 우너소를 끼워넣는 일을 반복한다.
> 시간 복잡도는 O(N)이 되고, 전체 시간 복잡도는 선택 정렬과 같은 O(N^2)이 된다.(최선의 경우 O(N)이다.) 또한 흔히 사용하는 O(N^2)정렬 중에서 가장 빠른 알고리즘이다.
* ### 시간 복잡도의 분할 상환 분석
#### 알고리즘의 시간 복잡도를 항상 반복문의 개수를 세는 것으로만 결정하지는 않는다. 가끔 분할 상환 분석(amortized analysis)을 사용한다.
## 4-6 수행 시간 어림짐작하기
* ### 주먹구구 법칙
#### 프로그래밍 대회의 시간 제한은 알고리즘의 시간 복잡도가 아니라 프로그램의 수행 시간을 기준으로 한다. 따라서 어떤 알고리즘이 이 문제를 해결할 수 있을지 알기 위해서는 입력의 최대 크기와 알고리즘의 시간 복잡도를 보고 수행 시간을 짐작해야 한다.
ex> 입력의 크기 N이 10000이고, 테스트 케이스 하나를 푸는데 시간 제한이 1초인 문제라고 가정
> 알고리즘의 시간 복잡도가 O(N^3)이면 이문제를 풀 수 있을까? O(N^2)이나 O(NlgN)은 어떨까?
#### 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 초과할 가능성이 크다.
N^3은 초과하고 NlgN은 초과하지 않는다. N^2또한 초과하지 않지만 이 경우 다른 요소들에 따라 10배정도는 쉽게 바뀔수 있기 때문에 조심하는 게 좋다.
* ### 주먹구구는 주먹구구일 뿐이다.
#### O(N^2) 알고리즘의 경우 시간 복잡도 외에도 다른 요소들을 참조해 시간 안에 수행될지 판단해야 한다. 고려해야 할 요소는 다음과 같다.
1.시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우 : O 표기법으로 시간 복잡도를 표현할 때는 상수나 최고차항 이외의 항들을 모두 지운다. 따라서 시간 복잡도 식에 입력의 최대 크기를 대입한 결과는 예측 값일 뿐이다.
2.반복문의 내부가 복잡한 경우  : 반복문 내부는 단순할수록 좋다.
3.메모리 사용 패턴이 복잡한 경우 : 현대의 CPU는 메모리에 있는 자료를 직접 접근하는 대신 캐시 메모리로 옮겨 처리한다.매번 자료를 CPU에서 가져올 필요없이 캐시에 이미 저장된 자료를 사용하게 된다.(실제 수행 속도에 영향을 미친다)
## 4-7 계산 복잡도 클래스 : P,NP,NP-완비
* ### 문제의 특성 공부하기
#### 계산 복잡도 이론은 각 문제의 특성을 공부하는 학문이다. 다음 두가지 문제를 비교해 보자
1. 정렬 문제 : 주어진 N개의 정수를 정렬한 결과는 무엇인가?
2. 부분 집합 합(subset sum) 문제 : N개의 수가 있을 대 이 중 몇 개를 골라내서 그들의 합이 S가 되도록 할 수 있는가?
#### 대개 빠른 알고리즘이 있는 문제는 계산적으로 쉽고, 빠른 알고리즘이 없는 문제는 어렵다고 말한다. 그렇다면 빠른 알고리즘의 기준이 무엇일까?
### 일반적으로 다항 시간 알고리즘이나 그보다 빠른 알고리즘들만 '빠르다'라고 말한다.
#### 계산 복잡도 이론에서는 이렇게 다항 시간 알고리즘이 존재하는 문제들의 집합을 P 문제라고 부른다. 예를 들어 1번 정렬 문제에서는 다항 시간 알고리즘이 존재하므로, 정렬 문제는 P 문제이다. 이런 P 문제처럼 문제들을 모아놓은 집합을 계산 복잡도 클래스(complexity class)라고 부른다.
* ### 난이도의 함정
#### 계산 복잡도 이론에서는 두 문제의 난이도를 비교하기 위해 환산(reduction)이라는 기법을 이용한다. 환산이란 한 문제를 다른 문제로 바꿔서 푸는 기법이다.
#### B의 입력을 적절히 변형해 A의 입력으로 바꾸는 환산 알고리즘이 존재한다고 가정하자. A를 푸는 가장 빠른 알고리즘을 가져오면, 환산을 통해 B를 푸는 알고리즘을 만들 수 있다.
ex> 정렬 문제와 최소치를 구하는 문제를 비교해 보면 정렬을 하는 도중 최소치를 먼저 구하기 때문에 정렬 문제는 최소치 문제 이상으로 어렵다고 말할 수 있다.
* ### NP 문제, NP 난해 문제
#### 어려운 문제의 기준이 되는 것을 SAT 문제(satisfiability problem)라고 한다. SAT 문제란 N개의 불린 값 변수로 구성된 논리식을 참으로 만드는 변수 값들의 조합을 찾는 문제이다. 이 SAT 문제는 중요한 의미를 가지고 있다. 모든 SAT 문제는 모든 NP 문제 이상으로 어렵다는 것이다. NP 문제란 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제를 의미한다.
예를 들어 부분 집합 합 문제는 NP 문제이다, 부분 집합 합 문제의 답이 주어졌을 때 이것이 원래 집합의 부분 집합인지, 그리고 원소들의 합이 S인지 다항 시간에 쉽게 확인할 수 있기 때문이다. 또 P문제들은 모두 NP 문제에도 포함이 된다.
#### SAT 문제가 NP 문제 이상으로 어렵다는 말은 SAT 을 다항 시간내에 풀 수 있으면 NP 문제도 풀수 있다는 얘기이다. 이런 속성을 갖는 문제를 NP-난해문제 라고한다.
또한 NP-난해이면서 Np인 문제를 NP-완비(NP-Complete)이라고 한다.
