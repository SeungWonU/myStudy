# 07 분할 정복
## 7-1 도입
#### 분할 정복은 가장 유명한 알고리즘 디자인 패러다임으로, 각개 격파라는 말로 간단히 설명 할 수 있다.
 하나의 알고리즘을 둘 이상의 부분 문제로 나눈 뒤 각 문제를 재귀 호출로 푸는 방식이다.

#### 일반적인 재귀 호출은 문제를 한 조각과 나머지 전체로 쪼개는 것이고 분할 정복은 비슷한 크기로 나누는 문제이다.

* ### 예제 : 수열의 빠른 합과 행렬의 빠른 제곱
#### 수열의 합 예제에서 1+2+3+4+...+n = fastSum()이라고 하면 분할 정복으로 계산할 경우  fastSum(n) = 2*fastSum(n/2)+ n^2/4가 된다.
``` c++
// 필수조건 : n은 자연수
// 1+2+..+n을 반환한다
int fastSum(int n){
//기저 사례
if(n==1) return 1;
if(n % 2 == 1) return fastSum(n-1) +n;
return 2*fastSum(n/2) + (n/2)*(n/2);
}
```
* ### 시간복잡도 분석
#### 방금 본 fastSum()을 분할 정복으로 푼 것과 일반적인 재귀 호출로 푼 경우 시간이 다르다. O(n) 과 O(lgn)이다.
* ### 행렬의 거듭제곱
####  A의 m거듭제곱인 경우 행렬의 곱셈이 O(n^3)이고 A^m이  O(m)이므로 O(n^3 * m) 이 된다.이는 시간이 오래걸리지만 분할 정복일 경우 얘기가 다르다.
A^m = A^(m/2) * A^(m/2) 로 해결하면 시간이 단축된다.
``` c++
// 정방행렬을 표현하는 SquareMatrix 클래스가 있다고 가정하자
class SquareMatirx;
// n*n 크기의 항등행렬을 반환하는 함수
SquareMatirx identity(int n);
//A^m을 반환한다.
SquareMatrix pow(const SquareMatirx&A, int m){
//기저 사례 : A^0 =1
if(m==0) return identity(A.size()));
if(m % 2>0) return pow(A,m-1) * A;// 홀수일때
SquareMatirx half = pow(A, m/2);

return half * half;
}
```
* ### 나누어 떨어지지 않을 때의 분할과 시간 복잡도
#### 방금 전 예제를 보면 홀수 부분에서 홀수를 무작정 절반으로 나누냐 or 홀수에서 1을뺴고 짝수로 만드냐 문제가 있는데 
무작정 나눌경우  ex) A^31 은 16,15로 쪼개진다. 16은 8로 15는 8,7로 쪼개지는데 8이 중복된다 진행될수록 중복되는 함수가 많아져 시간이 더 오래걸리게 된다.
따라서 분할 정복이더라도 부분 문제가 중복(overlapping)되는 문제를 삼가해야 한다.

* ### 예제 : 병합정렬과 퀵 정렬
#### 주어진 수열 크기 순서대로 정렬 하는 것과 분할 정복 패러다임을 기반으로 해서 만든 대표적인 것은 병합정렬과 퀵 정렬이다.
퀵은 분할에서 병합 정렬은 병합 단계에서 시간이 많이 걸리기 때문에 이를 참고해 알고리즘을 해결한다.
* ### 시간 복잡도 분석
#### 병합 정렬은 병합에 필요한 총 시간이 O(n)이고 분할될때 항상 절반으로 되기 때문에 O(lgn)이므로 O(nlgn)이다.
퀵 정렬은 항상 비슷한 크기로 나눌 수 없다. 택한 원소가 최대이면 크기가 하나씩 줄어들기 때문에 이런 최악의 경우 O(n^2)이 된다. 거의 절반 정도로 나눠지면 O(nlgn)으로 병합정렬과 같다.

* ### 예제 :카라츠바의 빠른 곱셈 알고리즘
 
