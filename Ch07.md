# 07 분할 정복
## 7-1 도입
#### 분할 정복은 가장 유명한 알고리즘 디자인 패러다임으로, 각개 격파라는 말로 간단히 설명 할 수 있다.
 하나의 알고리즘을 둘 이상의 부분 문제로 나눈 뒤 각 문제를 재귀 호출로 푸는 방식이다.

#### 일반적인 재귀 호출은 문제를 한 조각과 나머지 전체로 쪼개는 것이고 분할 정복은 비슷한 크기로 나누는 문제이다.

* ### 예제 : 수열의 빠른 합과 행렬의 빠른 제곱
#### 수열의 합 예제에서 1+2+3+4+...+n = fastSum()이라고 하면 분할 정복으로 계산할 경우  fastSum(n) = 2*fastSum(n/2)+ n^2/4가 된다.
``` c++
// 필수조건 : n은 자연수
// 1+2+..+n을 반환한다
int fastSum(int n){
//기저 사례
if(n==1) return 1;
if(n % 2 == 1) return fastSum(n-1) +n;
return 2*fastSum(n/2) + (n/2)*(n/2);
}
```
* ### 시간복잡도 분석
#### 방금 본 fastSum()을 분할 정복으로 푼 것과 일반적인 재귀 호출로 푼 경우 시간이 다르다. O(n) 과 O(lgn)이다.
* ### 행렬의 거듭제곱
####  A의 m거듭제곱인 경우 행렬의 곱셈이 O(n^3)이고 A^m이  O(m)이므로 O(n^3 * m) 이 된다.이는 시간이 오래걸리지만 분할 정복일 경우 얘기가 다르다.
A^m = A^(m/2) * A^(m/2) 로 해결하면 시간이 단축된다.
``` c++
// 정방행렬을 표현하는 SquareMatrix 클래스가 있다고 가정하자
class SquareMatirx;
// n*n 크기의 항등행렬을 반환하는 함수
SquareMatirx identity(int n);
//A^m을 반환한다.
SquareMatrix pow(const SquareMatirx&A, int m){
//기저 사례 : A^0 =1
if(m==0) return identity(A.size()));
if(m % 2>0) return pow(A,m-1) * A;// 홀수일때
SquareMatirx half = pow(A, m/2);

return half * half;
}
```
* ### 나누어 떨어지지 않을 때의 분할과 시간 복잡도
#### 방금 전 예제를 보면 홀수 부분에서 홀수를 무작정 절반으로 나누냐 or 홀수에서 1을뺴고 짝수로 만드냐 문제가 있는데 
무작정 나눌경우  ex) A^31 은 16,15로 쪼개진다. 16은 8로 15는 8,7로 쪼개지는데 8이 중복된다 진행될수록 중복되는 함수가 많아져 시간이 더 오래걸리게 된다.
따라서 분할 정복이더라도 부분 문제가 중복(overlapping)되는 문제를 삼가해야 한다.

