# 06 무식하기 풀기
## 6-1 도입
#### **완전 탐색**이란 가능한 방법을 **전부** 만들어 보는 알고리즘을 뜻한다.무식하게 푸는 것이 때론 빠른 알고리즘의 기반이 될 수 있다.

## 6-2 재귀 호출과 완전 탐색
* ### 재귀 호출
#### **재귀 함수**란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 **자기 자신을 호출해 실행하는 함수**를 가르킨다.
> #### 1부터 n까지의 합을 계산하는 반복 함수와 재귀 함수
```c++

int sum(int n){
int ret = 0;
for(int i=1;i<=n;++i)
ret+= i;
return ret;
}

int recursiveSum(int n){
if(n==1) return 1;
return n+ recursiveSum(n-1);
}
```
#### 재귀 함수는 더이상 쪼개지지 않는 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 이러한 작업들을 가리켜 기저 사례(base case)라고 한다.
> #### 위 예제에서 n==1 일때 기저 사례이다.
#### 기저 사례는 또한 재귀 호출에 반드시 존재해야 한다.

* ### 예제: 중첩 반복문 대체하기
## 6-3소풍 문제
> #### 예제 출력을 해야 하는데 입력 밖에 작성 못함..
```c++

int C;//테스트 케이스의 수(C<50)
int n;//학생의 수 
int m;//친구 쌍의 수

cin>>C;

for(int i=0;i<C;i++){
cin>>n;//(n>=2&&n<=10)
cin>>m \n;
int Num1[];

for(int i=0;i<n;i++)
Num1[i]=i;

int Num2[];

for(int i=0;i<n;i++)
Num2[i]=i;

list <int> l;

for(int i=0;i<m;i++)
{
	int k =99999;
	for(int j=0;j<2;j++)
	{
		int num=0;
		if(num==k)
		continue;
		cin>>num;//(num=>0&&num<n)
		k=num;
		l.pushback(num);
	}
}		
}
```
## 6-5 게임판 덮기
> #### 내생각 구현해보기
#### num[H][W]로 2차배열 생성 ->0,1로 검,흰 나누기 -> 흰색인 부분 1만 따로 봄-> 1의 개수가 3의 배수가 아니면 false
#### 흰색 칸 첫부분부터 시작함  상하좌우 중 상부터 확인 (흰색이면 채우기) ->상으로 갔다면 간 곳에서 좌우만 흰색인지 확인(좌부터 흰색인지 확인)
#### 상하로 움직일 경우 다음은 좌우만 가능/ 좌우로 움직인 경우 상하로 가능 옮긴 곳은 전부 검은색으로 변함 
#### 만약 3칸을 칠했다면  기저 사례로 다시 흰색바탕으로 시작함
#### 만약 3칸을 칠하지 못했다면 칠할수없기 떄문에 FALSE
### 풀이
#### 모든 경우의 수를 세는 문제이기 때문에 완전 탐색을 이용한다.
> #### 의문점: 풀이에서 가장 왼쪽위부터 시작하여 별표 표시한다음 그 칸을 채울수 있는 경우가 4개라 했는데 160쪽에 가장 왼쪽위는 채울 수 있는 칸이 2개이다.  왼쪽위라고 전부 4경우가 아닌것 같다 ?
## 6-7 최적화 문제
####완전 탐색은 최적화 문제를 풀기 위한 직관적인 방법이다. 모든 답을 생성해 보고 가장 좋은 것을 찾아내면 되기 때문이다.
####가장 유명한 최적화 문제는 외판원 문제(Traveling Sales-man Problem)
> ### 6-5/6-7 재귀 함수 부분 마지막 false 하는 부분을 모르겠다
